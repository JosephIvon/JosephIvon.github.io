<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.5.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.5.0" />






<meta name="description" content="#深入理解Objective-C的Runtime机制
导语Objective-C是基于C语言加入了面向对象特性和消息转发机制的动态语言，这意味着它不仅需要一个编译器，还需要runtime系统来动态创建类和对象，进行消息发送和转发。下面通过分析Apple开源的Runtime代码（我使用的版本是objc4-646.tar）来深入理解Objective-C的runtime机制。
动态 vs 静态语言Ob">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解Objective-C的Runtime机制">
<meta property="og:url" content="https://JosephIvon.github.io/2015/07/16/深入理解objective-c的runtime机制/index.html">
<meta property="og:site_name" content="凡文波的个人博客">
<meta property="og:description" content="#深入理解Objective-C的Runtime机制
导语Objective-C是基于C语言加入了面向对象特性和消息转发机制的动态语言，这意味着它不仅需要一个编译器，还需要runtime系统来动态创建类和对象，进行消息发送和转发。下面通过分析Apple开源的Runtime代码（我使用的版本是objc4-646.tar）来深入理解Objective-C的runtime机制。
动态 vs 静态语言Ob">
<meta property="og:image" content="http://ww4.sinaimg.cn/large/762694bagw1f46k2f38dkj20fa014jr8.jpg">
<meta property="og:image" content="http://ww4.sinaimg.cn/large/762694bagw1f46k2f38dkj20fa014jr8.jpg">
<meta property="og:image" content="http://ww4.sinaimg.cn/large/762694bagw1f46k2f38dkj20fa014jr8.jpg">
<meta property="og:image" content="http://ww4.sinaimg.cn/large/762694bagw1f46k2f38dkj20fa014jr8.jpg">
<meta property="og:image" content="http://ww4.sinaimg.cn/large/762694bagw1f46l0mgp59j20e00ep75m.jpg">
<meta property="og:image" content="http://ww2.sinaimg.cn/large/762694bagw1f46lsvffshj20980f474x.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/762694bagw1f46m8x0bpmj20fa0cfmxa.jpg">
<meta property="og:updated_time" content="2016-05-24T10:38:26.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="深入理解Objective-C的Runtime机制">
<meta name="twitter:description" content="#深入理解Objective-C的Runtime机制
导语Objective-C是基于C语言加入了面向对象特性和消息转发机制的动态语言，这意味着它不仅需要一个编译器，还需要runtime系统来动态创建类和对象，进行消息发送和转发。下面通过分析Apple开源的Runtime代码（我使用的版本是objc4-646.tar）来深入理解Objective-C的runtime机制。
动态 vs 静态语言Ob">
<meta name="twitter:image" content="http://ww4.sinaimg.cn/large/762694bagw1f46k2f38dkj20fa014jr8.jpg">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> 深入理解Objective-C的Runtime机制 | 凡文波的个人博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">凡文波的个人博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">最怕一生碌碌无为，却自欺欺人平凡可贵。</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                深入理解Objective-C的Runtime机制
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-07-16T23:22:53+08:00" content="2015-07-16">
              2015-07-16
            </time>
          </span>

          

          
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>#深入理解Objective-C的Runtime机制</p>
<h2 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h2><p>Objective-C是基于C语言加入了面向对象特性和消息转发机制的动态语言，这意味着它不仅需要一个编译器，还需要<em>runtime</em>系统来动态创建类和对象，进行消息发送和转发。下面通过分析Apple开源的<a href="http://opensource.apple.com/tarballs/objc4/" target="_blank" rel="external"><strong>Runtime代码</strong></a>（我使用的版本是objc4-646.tar）来深入理解Objective-C的<em>runtime</em>机制。</p>
<h2 id="动态-vs-静态语言"><a href="#动态-vs-静态语言" class="headerlink" title="动态 vs 静态语言"></a>动态 vs 静态语言</h2><p>Objective-C 是面相运行时的语言（<em>runtime oriented language</em>），就是说它会尽可能的把编译和链接时要执行的逻辑延迟到运行时。这就给了你很大的灵活性，你可以按需要把消息重定向给合适的对象，你甚至可以交换方法的实现，等等（译注：在 Objective-C 中调用一个对象的方法可以看成向一个对象发送消息, <strong>Method Swizzling</strong> 具体实现可以参看 <a href="https://github.com/rentzsch/jrswizzle" target="_blank" rel="external">jrswizzle</a>。这就需要使用 <em>runtime</em>，<em>runtime</em> 可以做对象自省查看他们正在做的和不能做的（<em>don’t respond to</em>）并且合适的分发消息（译注：感兴趣的同学可以查看 NSObject 类的 <code>– forwardingTargetForSelector:</code> 和 <code>– forwardInvocation:</code> 方法。(PS:不是 NSObject 协议）。如果我们和 C 这样的语言对比。在 C 里，你从 <code>main()</code> 方法开始写然后就是从上到下的写逻辑了并按你写代码的顺序执行程序。一个 C 的结构体不能转发函数执行请求到其他的目标上（<em>other targets</em>）。很可能你的程序是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &lt; stdio.h &gt;</span><br><span class="line">int main(int argc, const char **argv[])</span><br><span class="line">&#123;        </span><br><span class="line">    printf(&quot;Hello World!&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译器解析，优化然后把优化后的代码转成汇编：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line"> .align 4,0x90</span><br><span class="line"> .globl _main</span><br><span class="line">_main:</span><br><span class="line">Leh_func_begin1:</span><br><span class="line"> pushq %rbp</span><br><span class="line">Llabel1:</span><br><span class="line"> movq %rsp, %rbp</span><br><span class="line">Llabel2:</span><br><span class="line"> subq $16, %rsp</span><br><span class="line">Llabel3:</span><br><span class="line"> movq %rsi, %rax</span><br><span class="line"> movl %edi, %ecx </span><br><span class="line"> movl %ecx, -8(%rbp)</span><br><span class="line"> movq %rax, -16(%rbp) </span><br><span class="line"> xorb %al, %al </span><br><span class="line"> leaq LC(%rip), %rcx </span><br><span class="line"> movq %rcx, %rdi </span><br><span class="line"> call _printf </span><br><span class="line"> movl $0, -4(%rbp) </span><br><span class="line"> movl -4(%rbp), %eax </span><br><span class="line"> addq $16, %rsp </span><br><span class="line"> popq %rbp </span><br><span class="line"> ret</span><br><span class="line">Leh_func_end1: </span><br><span class="line"> .cstring</span><br><span class="line">LC: </span><br><span class="line"> .asciz &quot;Hello World!&quot;</span><br></pre></td></tr></table></figure>
<p>然后链接库并生成可执行程序（译注：如果你对 C 的编译链接过程还不熟悉可以参看 <a href="http://vdisk.weibo.com/s/G-kaugh74rPp" target="_blank" rel="external"><strong>Deep C and C++</strong></a>）。要和 Objective-C 对比的话，处理过程很相似，生成的代码依赖于是否有 Objective-C <em>Runtime</em> 库。当刚学 Objective-C 时，我们最先了解的(最简单的那种)是 Objective-C 中用括号包起来的代码像这样:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self doSomethingWithVar:var1];</span><br></pre></td></tr></table></figure>
<p>被转换为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSend(self,@selector(doSomethingWithVar:),var1);</span><br></pre></td></tr></table></figure>
<h2 id="Runtime数据结构"><a href="#Runtime数据结构" class="headerlink" title="Runtime数据结构"></a>Runtime数据结构</h2><p>在Objective-C中，使用 <code>[receiver message]</code> 语法并不会马上执行<strong>receiver</strong>对象的 <strong>message</strong> 方法的代码，而是向 <strong>receiver</strong> 发送一条 <strong>message</strong> 消息，这条消息可能由 <strong>receiver</strong> 来处理，也可能由转发给其他对象来处理，也有可能假装没有接收到这条消息而没有处理。其实 <code>[receiver message]</code> 被编译器转化为：</p>
<pre><code>id objc_msgSend ( id self, SEL op, ... );
</code></pre><p>下面从两个数据结构 <strong>id</strong> 和 <strong>SEL</strong> 来逐步分析和理解<em>Runtime</em>有哪些重要的数据结构。</p>
<h3 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a>SEL</h3><p><strong>SEL</strong>是函数<strong>objc_msgSend</strong>第二个参数的数据类型，表示方法选择器，按下面路径打开 <code>objc.h</code> 文件：</p>
<p><img src="http://ww4.sinaimg.cn/large/762694bagw1f46k2f38dkj20fa014jr8.jpg" alt=""></p>
<p>查看到SEL数据结构如下：</p>
<pre><code>typedef struct objc_selector *SEL;
</code></pre><p>其实它就是映射到方法的C字符串，你可以通过Objc编译器命令 <strong>@selector()</strong> 或者<em>Runtime</em>系统的 <strong>sel_registerName</strong> 函数来获取一个SEL类型的方法选择器。</p>
<p>如果你知道 <strong>selector</strong> 对应的方法名是什么，可以通过 <strong>NSString* NSStringFromSelector(SEL aSelector)</strong> 方法将<strong>SEL</strong>转化为字符串，再用<strong>NSLog</strong>打印。</p>
<h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><p>接下来看<strong>objc_msgSend</strong>第一个参数的数据类型<strong>id</strong>，<strong>id</strong>是通用类型指针，能够表示任何对象。按下面路径打开 <code>objc.h</code> 文件：</p>
<p><img src="http://ww4.sinaimg.cn/large/762694bagw1f46k2f38dkj20fa014jr8.jpg" alt=""></p>
<p>查看到<strong>id</strong>数据结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- /// Represents an instance of a class.</span><br><span class="line">- struct objc_object &#123;</span><br><span class="line">-     Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">- &#125;;</span><br><span class="line">-</span><br><span class="line">- /// A pointer to an instance of a class.</span><br><span class="line">- typedef struct objc_object *id;</span><br><span class="line">`</span><br></pre></td></tr></table></figure>
<p><strong>id</strong>其实就是一个指向<strong>objc_object</strong>结构体指针，它包含一个<strong>Class isa</strong>成员，根据<strong>isa</strong>指针就可以顺藤摸瓜找到对象所属的类。</p>
<p>注意：根据Apple的官方文档<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOImplementation.html" target="_blank" rel="external">Key-Value Observing Implementation Details</a>提及，<strong>key-value observing</strong>是使用<strong>isa-swizzling</strong>的技术实现的，<strong>isa</strong>指针在运行时被修改，指向一个中间类而不是真正的类。所以，你不应该使用<strong>isa</strong>指针来确定类的关系，而是使用<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Protocols/NSObject_Protocol/index.html#//apple_ref/occ/intfm/NSObject/class" target="_blank" rel="external"><strong>class</strong></a>方法来确定实例对象的类。</p>
<h3 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h3><p><strong>isa</strong>指针的数据类型是<strong>Class</strong>，<strong>Class</strong>表示对象所属的类，按下面路径打开 <code>objc.h</code> 文件：</p>
<p><img src="http://ww4.sinaimg.cn/large/762694bagw1f46k2f38dkj20fa014jr8.jpg" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- /// An opaque type that represents an Objective-C class.</span><br><span class="line">- typedef struct objc_class *Class;</span><br></pre></td></tr></table></figure>
<p>可以查看到<strong>Class</strong>其实就是一个<strong>objc_class</strong>结构体指针，但这个头文件找不到它的定义，需要在 <code>runtime.h</code> 才能找到<strong>objc_class</strong>结构体的定义。</p>
<p>按下面路径打开 <code>runtime.h</code> 文件：</p>
<p><img src="http://ww4.sinaimg.cn/large/762694bagw1f46k2f38dkj20fa014jr8.jpg" alt=""></p>
<p>查看到<strong>objc_class</strong>结构体定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- struct objc_class &#123;</span><br><span class="line">-     Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">-</span><br><span class="line">- #if !__OBJC2__</span><br><span class="line">-     Class super_class                                        OBJC2_UNAVAILABLE;</span><br><span class="line">-     const char *name                                         OBJC2_UNAVAILABLE;</span><br><span class="line">-     long version                                             OBJC2_UNAVAILABLE;</span><br><span class="line">-     long info                                                OBJC2_UNAVAILABLE;</span><br><span class="line">-     long instance_size                                       OBJC2_UNAVAILABLE;</span><br><span class="line">-     struct objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;</span><br><span class="line">-     struct objc_method_list **methodLists                    OBJC2_UNAVAILABLE;</span><br><span class="line">-     struct objc_cache *cache                                 OBJC2_UNAVAILABLE;</span><br><span class="line">-     struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;</span><br><span class="line">- #endif</span><br><span class="line">-</span><br><span class="line">- &#125; OBJC2_UNAVAILABLE;</span><br><span class="line">- /* Use `Class` instead of `struct objc_class *` */</span><br></pre></td></tr></table></figure>
<pre><code>注意：OBJC2_UNAVAILABLE是一个Apple对Objc系统运行版本进行约束的宏定义，主要为了兼容非Objective-C 2.0的遗留版本，但我们仍能从中获取一些有用信息。
</code></pre><p>让我们分析一些重要的成员变量表示什么意思和对应使用哪些数据结构。</p>
<p><strong>isa</strong>表示一个<strong>Class</strong>对象的<strong>Class</strong>，也就是<strong>Meta Class</strong>。在面向对象设计中，一切都是对象，<strong>Class</strong>在设计中本身也是一个对象。我们会在 <code>objc-runtime-new.h</code> 文件找到证据，发现<strong>objc_class</strong>有以下定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- struct objc_class : objc_object &#123;</span><br><span class="line">-   // Class ISA;</span><br><span class="line">-   Class superclass;</span><br><span class="line">-   cache_t cache;             // formerly cache pointer and vtable</span><br><span class="line">-   class_data_bits_t bits;    // class_rw_t * plus custom rr/alloc flags</span><br><span class="line">-</span><br><span class="line">-   ......</span><br><span class="line">- &#125;</span><br></pre></td></tr></table></figure>
<p>由此可见，结构体<strong>objc_class</strong>也是继承<strong>objc_object</strong>，说明<strong>Class</strong>在设计中本身也是一个对象。<br>其实<strong>Meta Class</strong>也是一个<strong>Class</strong>，那么它也跟其他<strong>Class</strong>一样有自己的<strong>isa</strong>和<strong>super_class</strong>指针，关系如下：</p>
<p><img src="http://ww4.sinaimg.cn/large/762694bagw1f46l0mgp59j20e00ep75m.jpg" alt=""></p>
<p>上图实线是<strong>super_class</strong>指针，虚线是<strong>isa</strong>指针。有几个关键点需要解释以下：<br></p>
<ul>
<li>1、<strong>Root class (class)</strong>其实就是<strong>NSObject</strong>，<strong>NSObject</strong>是没有超类的，所以<strong>Root class(class)</strong>的<strong>superclass</strong>指向<strong>nil</strong>.<br></li>
<li>2、每个<strong>Class</strong>都有一个<strong>isa</strong>指针指向唯一的<strong>Meta class</strong>.<br></li>
<li>3、<strong>Root class(meta)</strong>的<strong>superclass</strong>指向<strong>Root class(class)</strong>，也就是<strong>NSObject</strong>，形成一个回路.<br></li>
<li><p>4、每个<strong>Meta class</strong>的<strong>isa</strong>指针都指向<strong>Root class (meta)</strong>.<br></p>
</li>
<li><p><strong>super_class</strong>表示实例对象对应的父类；</p>
</li>
<li><strong>name</strong>表示类名；</li>
<li><strong>ivars</strong>表示多个成员变量，它指向<strong>objc_ivar_list</strong>结构体。在 <code>runtime.h</code> 可以看到它的定义：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- struct objc_ivar_list &#123;</span><br><span class="line">-   int ivar_count                                           OBJC2_UNAVAILABLE;</span><br><span class="line">- #ifdef __LP64__</span><br><span class="line">-   int space                                                OBJC2_UNAVAILABLE;</span><br><span class="line">- #endif</span><br><span class="line">-   /* variable length structure */</span><br><span class="line">-   struct objc_ivar ivar_list[1]                            OBJC2_UNAVAILABLE;</span><br><span class="line">- &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>objc_ivar_list</strong>其实就是一个链表，存储多个<strong>objc_ivar</strong>，而<strong>objc_ivar</strong>结构体存储类的单个成员变量信息。<br></li>
<li><strong>methodLists</strong>表示方法列表，它指向<strong>objc_method_list</strong>结构体的二级指针，可以动态修改<em>methodLists的值来添加成员方法，也是<strong>Category</strong>实现原理，同样也解释<em>*Category</em></em>不能添加属性的原因。在 <code>runtime.h</code> 可以看到它的定义：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- struct objc_method_list &#123;</span><br><span class="line">-   struct objc_method_list *obsolete                        OBJC2_UNAVAILABLE;</span><br><span class="line">-</span><br><span class="line">-   int method_count                                         OBJC2_UNAVAILABLE;</span><br><span class="line">- #ifdef __LP64__</span><br><span class="line">-   int space                                                OBJC2_UNAVAILABLE;</span><br><span class="line">- #endif</span><br><span class="line">-   /* variable length structure */</span><br><span class="line">-   struct objc_method method_list[1]                        OBJC2_UNAVAILABLE;</span><br><span class="line">- &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>同理，<strong>objc_method_list</strong>也是一个链表，存储多个<strong>objc_method</strong>，而<strong>objc_method</strong>结构体存储类的某个方法的信息。</p>
</li>
<li><p><strong>cache</strong>用来缓存经常访问的方法，它指向<strong>objc_cache</strong>结构体，后面会重点讲到。</p>
</li>
<li><strong>protocols</strong>表示类遵循哪些协议。</li>
</ul>
<h3 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h3><p><strong>Method</strong>表示类中的某个方法，在 <code>runtime.h</code> 文件中找到它的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- /// An opaque type that represents a method in a class definition.</span><br><span class="line">- typedef struct objc_method *Method;</span><br><span class="line">- struct objc_method &#123;</span><br><span class="line">-     SEL method_name                                          OBJC2_UNAVAILABLE;</span><br><span class="line">-     char *method_types                                       OBJC2_UNAVAILABLE;</span><br><span class="line">-     IMP method_imp                                           OBJC2_UNAVAILABLE;</span><br><span class="line">- &#125;</span><br></pre></td></tr></table></figure>
<p>其实<strong>Method</strong>就是一个指向<strong>objc_method</strong>结构体指针，它存储了方法名(<em>method_name</em>)、方法类型(<em>method_types</em>)和方法实现(<em>method_imp</em>)等信息。而<em>method_imp</em>的数据类型是<strong>IMP</strong>，它是一个函数指针，后面会重点提及。</p>
<h3 id="Ivar"><a href="#Ivar" class="headerlink" title="Ivar"></a>Ivar</h3><p><strong>Ivar</strong>表示类中的实例变量，在 <code>runtime.h</code> 文件中找到它的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- /// An opaque type that represents an instance variable.</span><br><span class="line">- typedef struct objc_ivar *Ivar;</span><br><span class="line">-</span><br><span class="line">- struct objc_ivar &#123;</span><br><span class="line">-     char *ivar_name                                          OBJC2_UNAVAILABLE;</span><br><span class="line">-     char *ivar_type                                          OBJC2_UNAVAILABLE;</span><br><span class="line">-     int ivar_offset                                          OBJC2_UNAVAILABLE;</span><br><span class="line">- #ifdef __LP64__</span><br><span class="line">-     int space                                                OBJC2_UNAVAILABLE;</span><br><span class="line">- #endif</span><br><span class="line">- &#125;</span><br></pre></td></tr></table></figure>
<p><strong>Ivar</strong>其实就是一个指向<strong>objc_ivar</strong>结构体指针，它包含了变量名(<em>ivar_name</em>)、变量类型(<em>ivar_type</em>)等信息。</p>
<h3 id="IMP"><a href="#IMP" class="headerlink" title="IMP"></a>IMP</h3><p>在上面讲<strong>Method</strong>时就说过，<strong>IMP</strong>本质上就是一个函数指针，指向方法的实现，在 <code>objc.h</code> 找到它的定义：</p>
<pre><code>/// A pointer to the function of a method implementation.
#if !OBJC_OLD_DISPATCH_PROTOTYPES
typedef void (*IMP)(void /* id, SEL, ... */ );
#else
typedef id (*IMP)(id, SEL, ...);
#endif   
</code></pre><p>当你向某个对象发送一条信息，可以由这个函数指针来指定方法的实现，它最终就会执行那段代码，这样可以绕开消息传递阶段而去执行另一个方法实现。</p>
<h3 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h3><p>顾名思义，<strong>Cache</strong>主要用来缓存，那它缓存什么呢？我们先在 <code>runtime.h</code> 文件看看它的定义：</p>
<pre><code>typedef struct objc_cache *Cache                             OBJC2_UNAVAILABLE;

struct objc_cache {
    unsigned int mask /* total = mask + 1 */                 OBJC2_UNAVAILABLE;
    unsigned int occupied                                    OBJC2_UNAVAILABLE;
    Method buckets[1]                                        OBJC2_UNAVAILABLE;
};
</code></pre><p><strong>Cache</strong>其实就是一个存储<strong>Method</strong>的链表，主要是为了优化方法调用的性能。当对象<strong>receiver</strong>调用方法<strong>message</strong>时，首先根据对象<strong>receiver</strong>的<strong>isa</strong>指针查找到它对应的类，然后在类的<strong>methodLists</strong>中搜索方法，如果没有找到，就使用<strong>super_class</strong>指针到父类中的<strong>methodLists</strong>查找，一旦找到就调用方法。如果没有找到，有可能消息转发，也可能忽略它。但这样查找方式效率太低，因为往往一个类大概只有20%的方法经常被调用，占总调用次数的80%。所以使用<strong>Cache</strong>来缓存经常调用的方法，当调用方法时，优先在<strong>Cache</strong>查找，如果没有找到，再到<strong>methodLists</strong>查找。</p>
<h2 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h2><p>前面从<strong>objc_msgSend</strong>作为入口，逐步深入分析<em>Runtime</em>的数据结构，了解每个数据结构的作用和它们之间关系后，我们正式转入消息发送这个正题。<br></p>
<p><strong>objc_msgSend函数</strong><br><br>在前面已经提过，当某个对象使用语法 <code>[receiver message]</code> 来调用某个方法时，其实 <code>[receiver message]</code> 被编译器转化为：</p>
<pre><code>- id objc_msgSend ( id self, SEL op, ... );
</code></pre><ul>
<li><p>现在让我们看一下<strong>objc_msgSend</strong>它具体是如何发送消息：</p>
<ul>
<li>1、首先根据<strong>receiver</strong>对象的<strong>isa</strong>指针获取它对应的<strong>class</strong>；</li>
<li>2、优先在<strong>class的cache</strong>查找<strong>message</strong>方法，如果找不到，再到<strong>methodLists</strong>查找；</li>
<li>3、如果没有在<strong>class</strong>找到，再到<strong>super_class</strong>查找；</li>
<li>4、一旦找到<strong>message</strong>这个方法，就执行它实现的<strong>IMP</strong>。</li>
</ul>
</li>
</ul>
<p><img src="http://ww2.sinaimg.cn/large/762694bagw1f46lsvffshj20980f474x.jpg" alt=""></p>
<h3 id="self与super"><a href="#self与super" class="headerlink" title="self与super"></a>self与super</h3><p>为了让大家更好地理解self和super，借用<a href="http://blog.sunnyxx.com" target="_blank" rel="external">sunnyxx博客</a>的<a href="http://blog.sunnyxx.com/2014/03/06/ios_exam_0_key/" target="_blank" rel="external">iOS程序员6级考试</a>一道题目：下面的代码分别输出什么？</p>
<pre><code>@implementation Son : Father
- (id)init
{
    self = [super init];
    if (self)
    {
        NSLog(@&quot;%@&quot;, NSStringFromClass([self class]));
       NSLog(@&quot;%@&quot;, NSStringFromClass([super class]));
    }
    return self;
}
@end
</code></pre><p><strong>self</strong>表示当前这个类的对象，而<strong>super</strong>是一个编译器标示符，和<strong>self</strong>指向同一个消息接受者。在本例中，无论是 <code>[self class]</code> 还是 <code>[super class]</code> ，接受消息者都是<strong>Son</strong>对象，但<strong>super</strong>与<strong>self</strong>不同的是，<strong>self</strong>调用<strong>class</strong>方法时，是在子类<strong>Son</strong>中查找方法，而<strong>super</strong>调用<strong>class</strong>方法时，是在父类<strong>Father</strong>中查找方法。<br><br>当调用 <code>[self class]</code> 方法时，会转化为<strong>objc_msgSend</strong>函数，这个函数定义如下：</p>
<pre><code>- id objc_msgSend(id self, SEL op, ...)
</code></pre><p>这时会从当前<strong>Son</strong>类的方法列表中查找，如果没有，就到<strong>Father</strong>类查找，还是没有，最后在<strong>NSObject</strong>类查找到。</p>
<p>我们可以从 <code>NSObject.mm</code> 文件中看到 <code>- (Class)class</code> 的实现：</p>
<pre><code>- (Class)class {
   return object_getClass(self);
}
</code></pre><p>所以 <code>NSLog(@&quot;%@&quot;, NSStringFromClass([self class]));</code> 会输出 <code>Son</code> .<br><br>当调用 <code>[super class]</code> 方法时，会转化为<strong>objc_msgSendSuper</strong>，这个函数定义如下：<br></p>
<pre><code>- id objc_msgSendSuper(struct objc_super *super, SEL op, ...)
</code></pre><p><strong>objc_msgSendSuper</strong>函数第一个参数<strong>super</strong>的数据类型是一个指向<strong>objc_super</strong>的结构体，从 <code>message.h</code> 文件中查看它的定义：</p>
<pre><code>/// Specifies the superclass of an instance.
struct objc_super {
    /// Specifies an instance of a class.
    __unsafe_unretained id receiver;

    /// Specifies the particular superclass of the instance to message.
#if !defined(__cplusplus)  &amp;&amp;  !__OBJC2__
    /* For compatibility with old objc-runtime.h header */
    __unsafe_unretained Class class;
#else
    __unsafe_unretained Class super_class;
#endif
    /* super_class is the first class to search */
};
#endif
</code></pre><p>结构体包含两个成员，第一个是<strong>receiver</strong>，表示某个类的实例。第二个是<strong>super_class</strong>表示当前类的父类。</p>
<p>这时首先会构造出<strong>objc_super</strong>结构体，这个结构体第一个成员是<strong>self</strong>，第二个成员是<strong>(id)class_getSuperclass(objc_getClass(“Son”))</strong>，实际上该函数会输出<strong>Father</strong>。然后在<strong>Father</strong>类查找<strong>class</strong>方法，查找不到，最后在<strong>NSObject</strong>查到。此时，内部使用<strong>objc_msgSend(objc_super-&gt;receiver</strong>, <strong>@selector(class))</strong>去调用，与 <code>[self class]</code> 调用相同，所以结果还是<strong>Son</strong>。</p>
<h3 id="隐藏参数self和-cmd"><a href="#隐藏参数self和-cmd" class="headerlink" title="隐藏参数self和_cmd"></a>隐藏参数self和_cmd</h3><p>当 <code>[receiver message]</code> 调用方法时，系统会在运行时偷偷地动态传入两个隐藏参数<strong>self</strong>和<strong>_cmd</strong>，之所以称它们为隐藏参数，是因为在源代码中没有声明和定义这两个参数。至于对于<strong>self</strong>的描述，上面已经解释非常清楚了，下面我们重点讲解<strong>_cmd</strong>。</p>
<p><strong>_cmd</strong>表示当前调用方法，其实它就是一个方法选择器<strong>SEL</strong>。一般用于判断方法名或在<strong>Associated Objects</strong>中唯一标识键名，后面在<strong>Associated Objects</strong>会讲到。</p>
<h2 id="方法解析与消息转发"><a href="#方法解析与消息转发" class="headerlink" title="方法解析与消息转发"></a>方法解析与消息转发</h2><p> <code>[receiver message]</code> 调用方法时，如果在<strong>message</strong>方法在<strong>receiver</strong>对象的类继承体系中没有找到方法，那怎么办？一般情况下，程序在运行时就会<strong>Crash</strong>掉，抛出  <code>unrecognized selector sent to…</code> 类似这样的异常信息。但在抛出异常之前，还有三次机会按以下顺序让你拯救程序。</p>
<ul>
<li>1.Method Resolution</li>
<li>2.Fast Forwarding</li>
<li>3.Normal Forwarding</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/762694bagw1f46m8x0bpmj20fa0cfmxa.jpg" alt=""></p>
<h3 id="Method-Resolution"><a href="#Method-Resolution" class="headerlink" title="Method Resolution"></a>Method Resolution</h3><p>首先Objective-C在运行时调用 <code>+ resolveInstanceMethod:</code> 或 <code>+ resolveClassMethod:</code> 方法，让你添加方法的实现。如果你添加方法并返回YES，那系统在运行时就会重新启动一次消息发送的过程。<br>举一个简单例子，定义一个类<strong>Message</strong>，它主要定义一个方法<strong>sendMessage</strong>，下面就是它的设计与实现：<br></p>
<pre><code>@interface Message : NSObject
- (void)sendMessage:(NSString *)word;
@end

@implementation Message
- (void)sendMessage:(NSString *)word
{
    NSLog(@&quot;normal way : send message = %@&quot;, word);
}
@end
</code></pre><p>如果我 <code>viewDidLoad</code> 方法中创建<strong>Message</strong>对象并调用 <code>sendMessage</code> 方法：<br></p>
<pre><code>- (void)viewDidLoad {
    [super viewDidLoad];
    Message *message = [Message new];
    [message sendMessage:@&quot;Sam Lau&quot;];
}
</code></pre><p>控制台会打印以下信息：</p>
<pre><code>normal way : send message = Sam Lau
</code></pre><p>但现在我将原来 <code>sendMessage</code> 方法实现给注释掉，覆盖 <code>resolveInstanceMethod</code> 方法：</p>
<pre><code>#pragma mark - Method Resolution
/// override resolveInstanceMethod or resolveClassMethod for changing sendMessage method implementation
+ (BOOL)resolveInstanceMethod:(SEL)sel
{
    if (sel == @selector(sendMessage:)) {
        class_addMethod([self class], sel, imp_implementationWithBlock(^(id self, NSString *word) {
            NSLog(@&quot;method resolution way : send message = %@&quot;, word);
        }), &quot;v@*&quot;);
    }
    return YES;
}
</code></pre><p>控制台就会打印以下信息：</p>
<pre><code>method resolution way : send message = Sam Lau
</code></pre><p>注意到上面代码有这样一个字符串”v@*，它表示方法的参数和返回值，详情请参考<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1" target="_blank" rel="external">Type Encodings</a>。</p>
<p>如果 <code>resolveInstanceMethod</code> 方法返回NO，运行时就跳转到下一步：消息转发(<em>Message Forwarding</em>)。</p>
<h3 id="Fast-Forwarding"><a href="#Fast-Forwarding" class="headerlink" title="Fast Forwarding"></a>Fast Forwarding</h3><p>如果目标对象实现 <code>- forwardingTargetForSelector:</code> 方法，系统就会在运行时调用这个方法，只要这个方法返回的不是<strong>nil</strong>或<strong>self</strong>，也会重启消息发送的过程，把这消息转发给其他对象来处理。否则，就会继续 <code>Normal Fowarding</code> 。</p>
<p>继续上面<strong>Message</strong>类的例子，将 <code>sendMessage</code> 和 <code>resolveInstanceMethod</code> 方法注释掉，然后添加 <code>forwardingTargetForSelector</code> 方法的实现：</p>
<pre><code>#pragma mark - Fast Forwarding
- (id)forwardingTargetForSelector:(SEL)aSelector
{
    if (aSelector == @selector(sendMessage:)) {
        return [MessageForwarding new];
    }
    return nil;
}
</code></pre><p>此时还缺一个转发消息的类<strong>MessageForwarding</strong>，这个类的设计与实现如下：</p>
<pre><code>@interface MessageForwarding : NSObject
- (void)sendMessage:(NSString *)word;
@end

@implementation MessageForwarding
- (void)sendMessage:(NSString *)word
{
    NSLog(@&quot;fast forwarding way : send message = %@&quot;, word);
}
@end
</code></pre><p>此时，控制台会打印以下信息：</p>
<pre><code>fast forwarding way : send message = Sam Lau
</code></pre><p>这里叫<strong>Fast</strong>，是因为这一步不会创建<strong>NSInvocation</strong>对象，但 <code>Normal Forwarding</code> 会创建它，所以相对于更快点。</p>
<h3 id="Normal-Forwarding"><a href="#Normal-Forwarding" class="headerlink" title="Normal Forwarding"></a>Normal Forwarding</h3><p>如果没有使用 <code>Fast Forwarding</code> 来消息转发，最后只有使用 <code>Normal Forwarding</code> 来进行消息转发。它首先调用 <code>methodSignatureForSelector:</code> 方法来获取函数的参数和返回值，如果返回为<strong>nil</strong>，程序会<strong>Crash</strong>掉，并抛出 <code>unrecognized selector sent to instance</code> 异常信息。如果返回一个函数签名，系统就会创建一个<strong>NSInvocation</strong>对象并调用 <code>-forwardInvocation:</code> 方法。</p>
<p>继续前面的例子，将 <code>forwardingTargetForSelector</code> 方法注释掉，添加 <code>methodSignatureForSelector</code> 和 <code>forwardInvocation</code> </p>
<p>方法的实现：</p>
<pre><code>#pragma mark - Normal Forwarding
- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector
{
    NSMethodSignature *methodSignature = [super methodSignatureForSelector:aSelector];
    if (!methodSignature) {
        methodSignature = [NSMethodSignature signatureWithObjCTypes:&quot;v@:*&quot;];
    }
    return methodSignature;
}
- (void)forwardInvocation:(NSInvocation *)anInvocation
{
    MessageForwarding *messageForwarding = [MessageForwarding new];
    if ([messageForwarding respondsToSelector:anInvocation.selector]) {
        [anInvocation invokeWithTarget:messageForwarding];
    }
}
</code></pre><p>关于这个例子的示例代码请到<a href="https://github.com/JosephIvon/learnGitHub.git" target="_blank" rel="external">Github</a>下载。</p>
<h3 id="三种方法的选择"><a href="#三种方法的选择" class="headerlink" title="三种方法的选择"></a>三种方法的选择</h3><p><em>Runtime</em>提供三种方式来将原来的方法实现代替掉，那该怎样选择它们呢？</p>
<ul>
<li><strong>Method Resolution：</strong>由于<em>Method Resolution</em>不能像消息转发那样可以交给其他对象来处理，所以只适用于在原来的类中代替掉。</li>
<li><strong>Fast Forwarding：</strong>它可以将消息处理转发给其他对象，使用范围更广，不只是限于原来的对象。</li>
<li><strong>Normal Forwarding：</strong>它跟<em>Fast Forwarding</em>一样可以消息转发，但它能通过<strong>NSInvocation</strong>对象获取更多消息发送的信息，例如：<strong>target</strong>、<strong>selector</strong>、<strong>arguments</strong>和返回值等信息。</li>
</ul>
<h3 id="Associated-Objects"><a href="#Associated-Objects" class="headerlink" title="Associated Objects"></a>Associated Objects</h3><p>当使用<strong>Category</strong>对某个类进行扩展时，有时需要存储属性，<strong>Category</strong>是不支持的，这时需要使用<strong>Associated Objects</strong>来给已存在的类<strong>Category</strong>添加自定义的属性。<strong>Associated Objects</strong>提供三个API来向对象添加、获取和删除关联值：</p>
<pre><code>- void objc_setAssociatedObject (id object, const void *key, id value, objc_AssociationPolicy policy )
- id objc_getAssociatedObject (id object, const void *key )
- void objc_removeAssociatedObjects (id object )    
</code></pre><ul>
<li>其中objc_AssociationPolicy是个枚举类型，它可以指定Objc内存管理的引用计数机制。</li>
</ul>
<pre><code>typedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) {
  OBJC_ASSOCIATION_ASSIGN = 0,           /**&lt; Specifies a weak reference to the associated object. */
  OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, /**&lt; Specifies a strong reference to the associated object.
                                          *   The association is not made atomically. */
  OBJC_ASSOCIATION_COPY_NONATOMIC = 3,   /**&lt; Specifies that the associated object is copied.
                                          *   The association is not made atomically. */
  OBJC_ASSOCIATION_RETAIN = 01401,       /**&lt; Specifies a strong reference to the associated object.
                                          *   The association is made atomically. */
  OBJC_ASSOCIATION_COPY = 01403          /**&lt; Specifies that the associated object is copied.
                                          *   The association is made atomically. */
};
</code></pre><p>下面有个关于 <code>NSObject+AssociatedObject Category</code> 添加属性 <code>associatedObject</code> 的示例代码：<br><br><strong>NSObject+AssociatedObject.h</strong></p>
<pre><code>@interface NSObject (AssociatedObject)
@property (strong, nonatomic) id associatedObject;
@end
</code></pre><p><strong>NSObject+AssociatedObject.m</strong></p>
<pre><code>@implementation NSObject (AssociatedObject)
- (void)setAssociatedObject:(id)associatedObject
{
    objc_setAssociatedObject(self, @selector(associatedObject), associatedObject, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
}
- (id)associatedObject
{
    return objc_getAssociatedObject(self, _cmd);
}
@end
</code></pre><p> <code>Associated Objects</code> 的<strong>key</strong>要求是唯一并且是常量，而<strong>SEL</strong>是满足这个要求的，所以上面的采用隐藏参数<strong>_cmd</strong>作为<strong>key</strong>。</p>
<h3 id="Method-Swizzling"><a href="#Method-Swizzling" class="headerlink" title="Method Swizzling"></a>Method Swizzling</h3><p> <code>Method Swizzling</code> 就是在运行时将一个方法的实现代替为另一个方法的实现。如果能够利用好这个技巧，可以写出简洁、有效且维护性更好的代码。可以参考两篇关于Method Swizzling技巧的文章：</p>
<ul>
<li><a href="https://github.com/JosephIvon/learnGitHub.git" target="_blank" rel="external">nshipster Method Swizzling</a></li>
<li><a href="http://tech.glowing.com/cn/method-swizzling-aop/" target="_blank" rel="external">Method Swizzling和AOP实践</a></li>
</ul>
<h3 id="Aspect-Oriented-Programming-AOP"><a href="#Aspect-Oriented-Programming-AOP" class="headerlink" title="Aspect-Oriented Programming(AOP)"></a>Aspect-Oriented Programming(AOP)</h3><p>类似记录日志、身份验证、缓存等事务非常琐碎，与业务逻辑无关，很多地方都有，又很难抽象出一个模块，这种程序设计问题，业界给它们起了一个名字叫横向关注点(<em>Cross-cutting concern</em>)，<a href="https://en.wikipedia.org/wiki/Aspect-oriented_programming" target="_blank" rel="external">AOP</a>作用就是分离横向关注点(<em>Cross-cutting concern</em>)来提高模块复用性，它可以在既有的代码添加一些额外的行为(记录日志、身份验证、缓存)而无需修改代码。</p>
<h3 id="危险性"><a href="#危险性" class="headerlink" title="危险性"></a>危险性</h3><p>Method Swizzling就像一把瑞士小刀，如果使用得当，它会有效地解决问题。但使用不当，将带来很多麻烦。在stackoverflow上有人已经提出这样一个问题：<a href="http://stackoverflow.com/questions/5339276/what-are-the-dangers-of-method-swizzling-in-objective-c" target="_blank" rel="external">What are the Dangers of Method Swizzling in Objective C?</a>，它的危险性主要体现以下几个方面：</p>
<ul>
<li>Method swizzling is not atomic</li>
<li>Changes behavior of un-owned code</li>
<li>Possible naming conflicts</li>
<li>Swizzling changes the method’s arguments</li>
<li>The order of swizzles matters</li>
<li>Difficult to understand (looks recursive)</li>
<li>Difficult to debug</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>虽然在平时项目不是经常用到Objective-C的<em>Runtime</em>特性，但当你阅读一些iOS开源项目时，你就会发现很多时候都会用到。所以深入理解Objective-C的<em>Runtime</em>数据结构、消息转发机制有助于你更容易地阅读和学习开源项目。</p>
<h4 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h4><ul>
<li><a href="http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/" target="_blank" rel="external">玉令天下博客的Objective-C Runtime</a></li>
<li><a href="http://tech.glowing.com/cn/objective-c-runtime/" target="_blank" rel="external">顾鹏博客的Objective-C Runtime</a></li>
<li><a href="http://nshipster.com/associated-objects/" target="_blank" rel="external">Associated Objects</a></li>
<li><a href="http://nshipster.com/method-swizzling/" target="_blank" rel="external">Method Swizzling</a></li>
<li><a href="http://tech.glowing.com/cn/method-swizzling-aop/" target="_blank" rel="external">Method Swizzling和AOP实践</a></li>
<li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ObjCRuntimeRef/index.html#//apple_ref/doc/uid/TP40001418" target="_blank" rel="external">Objective-C Runtime Reference</a></li>
<li><a href="">What are the Dangers of Method Swizzling in Objective C?</a></li>
<li><a href="http://blog.sunnyxx.com/2014/03/06/ios_exam_0_key/" target="_blank" rel="external">iOS程序员6级考试（答案和解释)</a></li>
</ul>

      
    </div>

    <div>
      
        
      
    </div>

    <footer class="post-footer">
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2015/07/11/markdown常用语法/" rel="next" title="Markdown常用语法">
                <i class="fa fa-chevron-left"></i> Markdown常用语法
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2015/07/21/ios多线程技术/" rel="prev" title="iOS多线程技术">
                iOS多线程技术 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/default_avatar.jpg"
               alt="JosephIvon" />
          <p class="site-author-name" itemprop="name">JosephIvon</p>
          <p class="site-description motion-element" itemprop="description">iOS developer</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">7</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        <div class="links-of-blogroll motion-element">
          
        </div>

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#导语"><span class="nav-number">1.</span> <span class="nav-text">导语</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#动态-vs-静态语言"><span class="nav-number">2.</span> <span class="nav-text">动态 vs 静态语言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Runtime数据结构"><span class="nav-number">3.</span> <span class="nav-text">Runtime数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SEL"><span class="nav-number">3.1.</span> <span class="nav-text">SEL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#id"><span class="nav-number">3.2.</span> <span class="nav-text">id</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Class"><span class="nav-number">3.3.</span> <span class="nav-text">Class</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Method"><span class="nav-number">3.4.</span> <span class="nav-text">Method</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Ivar"><span class="nav-number">3.5.</span> <span class="nav-text">Ivar</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IMP"><span class="nav-number">3.6.</span> <span class="nav-text">IMP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Cache"><span class="nav-number">3.7.</span> <span class="nav-text">Cache</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#消息发送"><span class="nav-number">4.</span> <span class="nav-text">消息发送</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#self与super"><span class="nav-number">4.1.</span> <span class="nav-text">self与super</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#隐藏参数self和-cmd"><span class="nav-number">4.2.</span> <span class="nav-text">隐藏参数self和_cmd</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#方法解析与消息转发"><span class="nav-number">5.</span> <span class="nav-text">方法解析与消息转发</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Method-Resolution"><span class="nav-number">5.1.</span> <span class="nav-text">Method Resolution</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Fast-Forwarding"><span class="nav-number">5.2.</span> <span class="nav-text">Fast Forwarding</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Normal-Forwarding"><span class="nav-number">5.3.</span> <span class="nav-text">Normal Forwarding</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三种方法的选择"><span class="nav-number">5.4.</span> <span class="nav-text">三种方法的选择</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Associated-Objects"><span class="nav-number">5.5.</span> <span class="nav-text">Associated Objects</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Method-Swizzling"><span class="nav-number">5.6.</span> <span class="nav-text">Method Swizzling</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Aspect-Oriented-Programming-AOP"><span class="nav-number">5.7.</span> <span class="nav-text">Aspect-Oriented Programming(AOP)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#危险性"><span class="nav-number">5.8.</span> <span class="nav-text">危险性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">5.9.</span> <span class="nav-text">总结</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#扩展阅读"><span class="nav-number">5.9.1.</span> <span class="nav-text">扩展阅读</span></a></li></ol></li></ol></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">JosephIvon</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  


  




<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=0.5.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=0.5.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=0.5.0"></script>
<script type="text/javascript" src="/vendors/jquery-scrollintoview/jquery.scrollintoview.min.js?v=0.5.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=0.5.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=0.5.0"></script>



  



  



  
  
  

  

  

</body>
</html>
