<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.5.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.5.0" />






<meta name="description" content="iOS多线程技术导图
基本概念
进程：  一个具有一定独立功能的程序关于某个数据集合的一次运行活动。可以理解成一个运行中的应用程序。
线程：  程序执行流的最小单元，线程是进程中的一个实体。  
同步：  只能在当前线程按先后顺序依次执行，不开启新线程。
异步：  可以在当前线程开启多个新线程执行，可不按顺序执行。
队列：  装载线程任务的队形结构。  
并发：  线程执行可以同时一起进行执行。">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS多线程技术">
<meta property="og:url" content="https://JosephIvon.github.io/2015/07/21/ios多线程技术/index.html">
<meta property="og:site_name" content="凡文波的个人博客">
<meta property="og:description" content="iOS多线程技术导图
基本概念
进程：  一个具有一定独立功能的程序关于某个数据集合的一次运行活动。可以理解成一个运行中的应用程序。
线程：  程序执行流的最小单元，线程是进程中的一个实体。  
同步：  只能在当前线程按先后顺序依次执行，不开启新线程。
异步：  可以在当前线程开启多个新线程执行，可不按顺序执行。
队列：  装载线程任务的队形结构。  
并发：  线程执行可以同时一起进行执行。">
<meta property="og:image" content="http://ww3.sinaimg.cn/large/762694bagw1f46q2rusl5j20ec0ctgmb.jpg">
<meta property="og:image" content="https://github.com/minggo620/iOSMutipleThread/blob/master/picture/mutiplethread1.gif?raw=true">
<meta property="og:image" content="https://github.com/minggo620/iOSMutipleThread/blob/master/picture/mutiplethread2.gif?raw=true">
<meta property="og:image" content="https://github.com/minggo620/iOSMutipleThread/blob/master/picture/mutiplethread3.gif?raw=true">
<meta property="og:updated_time" content="2016-05-24T14:19:56.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="iOS多线程技术">
<meta name="twitter:description" content="iOS多线程技术导图
基本概念
进程：  一个具有一定独立功能的程序关于某个数据集合的一次运行活动。可以理解成一个运行中的应用程序。
线程：  程序执行流的最小单元，线程是进程中的一个实体。  
同步：  只能在当前线程按先后顺序依次执行，不开启新线程。
异步：  可以在当前线程开启多个新线程执行，可不按顺序执行。
队列：  装载线程任务的队形结构。  
并发：  线程执行可以同时一起进行执行。">
<meta name="twitter:image" content="http://ww3.sinaimg.cn/large/762694bagw1f46q2rusl5j20ec0ctgmb.jpg">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> iOS多线程技术 | 凡文波的个人博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">凡文波的个人博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">最怕一生碌碌无为，却自欺欺人平凡可贵。</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                iOS多线程技术
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-07-21T22:55:26+08:00" content="2015-07-21">
              2015-07-21
            </time>
          </span>

          

          
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="iOS多线程技术"><a href="#iOS多线程技术" class="headerlink" title="iOS多线程技术"></a>iOS多线程技术</h1><h2 id="导图"><a href="#导图" class="headerlink" title="导图"></a>导图</h2><p><img src="http://ww3.sinaimg.cn/large/762694bagw1f46q2rusl5j20ec0ctgmb.jpg" alt=""></p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ol>
<li>进程：  一个具有一定独立功能的程序关于某个数据集合的一次运行活动。可以理解成一个运行中的应用程序。</li>
<li>线程：  程序执行流的最小单元，线程是进程中的一个实体。  </li>
<li>同步：  只能在当前线程按先后顺序依次执行，不开启新线程。</li>
<li>异步：  可以在当前线程开启多个新线程执行，可不按顺序执行。</li>
<li>队列：  装载线程任务的队形结构。  </li>
<li>并发：  线程执行可以同时一起进行执行。</li>
<li>串行：  线程执行只能依次逐一先后有序的执行。  </li>
</ol>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="什么是多线程"><a href="#什么是多线程" class="headerlink" title="什么是多线程"></a>什么是多线程</h3><pre><code>1个进程中可以开启多条线程，每条线程可以并行（同时）执行不同的任务
</code></pre><h3 id="多线程的原理"><a href="#多线程的原理" class="headerlink" title="多线程的原理"></a>多线程的原理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">同一时间，CPU只能处理1条线程，只有1条线程在工作（执行）</span><br><span class="line">多线程并发（同时）执行，其实是CPU快速地在多条线程之间调度（切换）</span><br><span class="line">如果CPU调度线程的时间足够快，就造成了多线程并发执行的假象</span><br></pre></td></tr></table></figure>
<p>思考：如果线程非常非常多，会发生什么情况？<br></p>
<pre><code>CPU会在N多线程之间调度，CPU会累死，消耗大量的CPU资源
每条线程被调度执行的频次会降低（线程的执行效率降低）
</code></pre><h3 id="多线程的优缺点"><a href="#多线程的优缺点" class="headerlink" title="多线程的优缺点"></a>多线程的优缺点</h3><ul>
<li>多线程的优点<br></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 能适当提高程序的执行效率</span><br><span class="line">- 能适当提高资源利用率（CPU、内存利用率)</span><br></pre></td></tr></table></figure>
<ul>
<li>多线程的缺点<br></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 开启线程需要占用一定的内存空间（默认情况下，主线程占用1M，子线程占用512KB），如果开启大量的线程，会占用大量的内存空间，降低程序的性能</span><br><span class="line">- 线程越多，CPU在调度线程上的开销就越大</span><br><span class="line">- 程序设计更加复杂：比如线程之间的通信、多线程的数据共享</span><br></pre></td></tr></table></figure>
<ul>
<li>多线程在iOS开发中的应用<br></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- 主线程:一个iOS程序运行后，默认会开启1条线程，称为“主线程”或“UI线程”</span><br><span class="line">- 主线程的主要作用:</span><br><span class="line">   1) 显示\刷新UI界面</span><br><span class="line">   2) 处理UI事件（比如点击事件、滚动事件、拖拽事件等）</span><br><span class="line"> </span><br><span class="line">- 主线程的使用注意:别将比较耗时的操作放到主线程中。</span><br><span class="line">- 耗时操作会卡住主线程，严重影响UI的流畅度，给用户一种“卡”的坏体验</span><br></pre></td></tr></table></figure>
<h3 id="iOS-中其实目前有-4-套多线程方案，他们分别是："><a href="#iOS-中其实目前有-4-套多线程方案，他们分别是：" class="headerlink" title="iOS 中其实目前有 4 套多线程方案，他们分别是："></a>iOS 中其实目前有 4 套多线程方案，他们分别是：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- Pthreads</span><br><span class="line">- NSThread</span><br><span class="line">- GCD</span><br><span class="line">- NSOperation &amp; NSOperationQueue</span><br></pre></td></tr></table></figure>
<h3 id="iOS多线程对比"><a href="#iOS多线程对比" class="headerlink" title="iOS多线程对比"></a>iOS多线程对比</h3><p>####1. pthread<br>一套通用的多线程API，适用Unix\Linux\Windows等系统。<br>1）优点：跨平台\可移植。<br>2）缺点：适用难度大。</p>
<p>####2. NSThread<br>每个NSThread对象对应一个线程，真正最原始的线程。<br>1）优点：NSThread 轻量级最低，相对简单。<br>2）缺点：手动管理所有的线程活动，如生命周期、线程同步、睡眠等。</p>
<p>####3. NSOperation<br>自带线程管理的抽象类。<br>1）优点：自带线程周期管理，操作上可更注重自己逻辑。<br>2）缺点：面向对象的抽象类，只能实现它或者使用它定义好的两个子类：NSInvocationOperation 和 NSBlockOperation。</p>
<p>####4. GCD<br>Grand Central Dispatch (GCD)是Apple开发的一个多核编程的解决方法。<br>1）优点：最高效，避开并发陷阱。<br>2）缺点：基于C实现。</p>
<p>####5. 选择小结<br>1）简单而安全的选择NSOperation实现多线程即可。<br>2）处理大量并发数据，又追求性能效率的选择GCD。<br>3）NSThread本人选择基本上是在做些小测试上使用，当然也可以基于此造个轮子。</p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>###1. pthread<br><strong>Linux</strong>系统下的多线程遵循<strong>POSIX</strong>线程接口，称为<strong>pthread</strong>。编写<strong>Linux</strong>下的多线程程序，需要使用头文件 <code>pthread.h</code> ，连接时需要使用库 <code>libpthread.a</code> 。与<strong>vxworks</strong>上任务的概念类似，都是调度的最小单元，都有共享的堆、栈、代码区、全局变量等。</p>
<h4 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h4><pre><code>int  pthread_create(pthread_t  *  thread,
                    pthread_attr_t * attr,
                    void * (*start_routine)(void *),
                    void * arg)
</code></pre><ul>
<li>thread：返回创建的线程的ID</li>
<li>attr：线程属性，调度策略、优先级等都在这里设置，如果为NULL则表示用默认属性</li>
<li>start_routine：线程入口函数，可以返回一个void*类型的返回值，该返回值可由pthread_join()捕获</li>
<li>arg：传给start_routine的参数， 可以为NULL   </li>
<li>返回值：成功返回0</li>
</ul>
<p>iOS多线程重点不在pthread，感兴趣可以参看博客：<a href="http://blog.chinaunix.net/uid-20528014-id-333508.html" target="_blank" rel="external">pthread编程基础 </a></p>
<p>###2. NSThread<br><strong>2.1）三种实现开启线程方式：</strong><br>①.动态实例化  </p>
<pre><code>NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(loadImageSource:) object:imgUrl];
thread.threadPriority = 1;// 设置线程的优先级(0.0 - 1.0，1.0最高级)
[thread start];  
</code></pre><p>②.静态实例化  </p>
<pre><code>[NSThread detachNewThreadSelector:@selector(loadImageSource:) toTarget:self withObject:imgUrl];   
</code></pre><p>③.隐式实例化    </p>
<pre><code>[self performSelectorInBackground:@selector(loadImageSource:) withObject:imgUrl];  
</code></pre><p>有了以上的知识点，可以试探了一下编写场景选择中的“图片加载”的基本功能了。  </p>
<p><strong>2.2）使用这三种方式编写代码</strong></p>
<pre><code>//动态创建线程
-(void)dynamicCreateThread{

    NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(loadImageSource:) object:imgUrl];
    thread.threadPriority = 1;// 设置线程的优先级(0.0 - 1.0，1.0最高级)
    thread.name = @&quot;下载&quot;;// 设置线程的名字
    [thread start];
}

//静态创建线程
-(void)staticCreateThread{

    [NSThread detachNewThreadSelector:@selector(loadImageSource:) toTarget:self withObject:imgUrl];

}

//隐式创建并启动线程
-(void)implicitCreateThread{

    [self performSelectorInBackground:@selector(loadImageSource:) withObject:imgUrl];
}

-(void)loadImageSource:(NSString *)url{
    NSData *imgData = [NSData dataWithContentsOfURL:[NSURL URLWithString:url]];
    UIImage *image = [UIImage imageWithData:imgData];
    if (imgData!=nil) {
        [self performSelectorOnMainThread:@selector(refreshImageView:) withObject:image waitUntilDone:YES];
    }else{
        NSLog(@&quot;there no image data&quot;);
    }

}

-(void)refreshImageView:(UIImage *)image{
    [self.imageView setImage:image];
}
</code></pre><p><strong>2.3）看先效果图</strong><br><img src="https://github.com/minggo620/iOSMutipleThread/blob/master/picture/mutiplethread1.gif?raw=true" alt="NSThread多线程加载效果">  </p>
<p><strong>1.4）NSThread的拓展认识</strong><br>①获取当前线程    </p>
<pre><code>NSThread *current = [NSThread currentThread];   
</code></pre><p>②获取主线程  </p>
<pre><code>NSThread *main = [NSThread mainThread];   
</code></pre><p>③暂停当前线程  </p>
<pre><code>[NSThread sleepForTimeInterval:2];  
</code></pre><p>  或者：</p>
<pre><code>NSDate *date = [NSDate dateWithTimeInterval:2 sinceDate:[NSDate date]];
[NSThread sleepUntilDate:date];
</code></pre><p>④线程之间通信  </p>
<pre><code>//在指定线程上执行操作
[self performSelector:@selector(run) onThread:thread withObject:nil waitUntilDone:YES]; 
//在主线程上执行操作
[self performSelectorOnMainThread:@selector(run) withObject:nil waitUntilDone:YES]; 
//在当前线程执行操作
[self performSelector:@selector(run) withObject:nil]; 
</code></pre><p>显然动态创建线程多了几行代码，其实就是那几行代码，如果重复编写数遍那是一件多么不爽的事情。首次看来静态方法创作线程和隐式创建线程显得比较方便，简洁。从知识结构来说，讲到这里应该讲述一下<strong>线程锁</strong>，鉴于并不常用和文章过长就不在此详细讲述，有兴趣可以自行查阅。</p>
<p>###3. NSOperation<br>主要的实现方式：结合NSOperation和NSOperationQueue实现多线程编程。</p>
<ul>
<li>实例化NSOperation的子类，绑定执行的操作。</li>
<li>创建NSOperationQueue队列，将NSOperation实例添加进来。</li>
<li>系统会自动将NSOperationQueue队列中检测取出和执行NSOperation的操作。    </li>
</ul>
<p><strong>3.1）使用NSOperation的子类实现创作线程。</strong><br>①.NSInvocationOperation创建线程。  </p>
<pre><code>NSInvocationOperation *invocationOperation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(loadImageSource:) object:imgUrl];
//[invocationOperation start];//直接会在当前线程主线程执行
NSOperationQueue *queue = [[NSOperationQueue alloc]init];
[queue addOperation:invocationOperation];  
</code></pre><p>②.NSBlockOperation创建线程  </p>
<pre><code>NSBlockOperation *blockOperation = [NSBlockOperation blockOperationWithBlock:^{
    [self loadImageSource:imgUrl];
}];

NSOperationQueue *queue = [[NSOperationQueue alloc]init];
[queue addOperation:blockOperation];  
</code></pre><p>③.自定义NSOperation子类实现main方法  </p>
<p>实现main方法  </p>
<pre><code>-(void)main {    
    // Do somthing
} 
</code></pre><ul>
<li><p>创建线程实例并添加到队列中    </p>
<p>  LoadImageOperation *imageOperation = [LoadImageOperation new];<br>  imageOperation.loadDelegate = self;<br>  imageOperation.imgUrl = imgUrl;</p>
<p>  NSOperationQueue *queue = [[NSOperationQueue alloc]init];<br>  [queue addOperation:imageOperation];</p>
</li>
</ul>
<p><strong>3.2）使用这三种方式编写代码</strong></p>
<p>创建各个实例并添加到队列表当中  </p>
<pre><code>//使用子类NSInvocationOperation
-(void)useInvocationOperation{
    NSInvocationOperation *invocationOperation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(loadImageSource:) object:imgUrl];
    //[invocationOperation start];//直接会在当前线程主线程执行
    NSOperationQueue *queue = [[NSOperationQueue alloc]init];
    [queue addOperation:invocationOperation];

}

//使用子类NSBlockOperation
-(void)useBlockOperation{

    NSBlockOperation *blockOperation = [NSBlockOperation blockOperationWithBlock:^{
        [self loadImageSource:imgUrl];
    }];

    NSOperationQueue *queue = [[NSOperationQueue alloc]init];
    [queue addOperation:blockOperation];

}
//使用继承NSOperation
-(void)useSubclassOperation{

    LoadImageOperation *imageOperation = [LoadImageOperation new];
    imageOperation.loadDelegate = self;
    imageOperation.imgUrl = imgUrl;

    NSOperationQueue *queue = [[NSOperationQueue alloc]init];
    [queue addOperation:imageOperation];
}

-(void)loadImageSource:(NSString *)url{

    NSData *imgData = [NSData dataWithContentsOfURL:[NSURL URLWithString:url]];
    UIImage *image = [UIImage imageWithData:imgData];
    if (imgData!=nil) {
        [self performSelectorOnMainThread:@selector(refreshImageView1:) withObject:image waitUntilDone:YES];
    }else{
        NSLog(@&quot;there no image data&quot;);
    }

}

-(void)refreshImageView1:(UIImage *)image{
    [self.loadingLb setHidden:YES];
    [self.imageView setImage:image];
}

-(void) loadImageFinish:(UIImage *)image{
    [self.loadingLb setHidden:YES];
    [self.imageView setImage:image];
}
</code></pre><p>附自定义NSOperation子类main主要代码实现  </p>
<pre><code>- (void)main {

    if (self.isCancelled) return;

    NSURL *url = [NSURL URLWithString:self.imgUrl];
    NSData *imageData = [NSData dataWithContentsOfURL:url];

    if (self.loadDelegate!=nil&amp;&amp;[self.loadDelegate respondsToSelector:@selector(loadImageFinish:)]) {

        [(NSObject *)self.loadDelegate performSelectorOnMainThread:@selector(loadImageFinish:) withObject:image waitUntilDone:NO];
    }
}
</code></pre><p><strong>3.3）看先效果图</strong><br><img src="https://github.com/minggo620/iOSMutipleThread/blob/master/picture/mutiplethread2.gif?raw=true" alt="NSOperation多线程加载效果"></p>
<p>###4. GCD多线程<br>GCD是Apple开发，据说高性能的多线程解决方案。既然这样，就细说一下这个解决方案。<br>进过Nsthread和NSOperation的讲述和上边的基础概念，可以开始组合用起来吧。<strong>并发队列</strong>、<strong>串行队列</strong>都用起来。<br><strong>4.1）分发队列种类(dispatch queue)</strong><br>①.UI主线程队列 main queue</p>
<pre><code>dispatch_get_main_queue()  
</code></pre><p>②.并行队列global dispatch queue  </p>
<pre><code>dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)  
</code></pre><p>这里的两个参数得说明一下：第一个参数用于指定优先级，分别使用DISPATCH_QUEUE_PRIORITY_HIGH和DISPATCH_QUEUE_PRIORITY_LOW两个常量来获取高和低优先级的两个queue；第二个参数目前未使用到，默认0即可</p>
<p>③.串行队列serial queues  </p>
<pre><code>dispatch_queue_create(&quot;minggo.app.com&quot;, NULL);  
</code></pre><p><strong>4.2）6中多线程实现</strong><br>①后台执行线程创建</p>
<pre><code>dispatch_async(dispatch_get_global_queue(0, 0), ^{
    [self loadImageSource:imgUrl1];
});
</code></pre><p>②UI线程执行(只是为了测试，长时间加载内容不放在主线程)</p>
<pre><code>dispatch_async(dispatch_get_main_queue(), ^{
    [self loadImageSource:imgUrl1];
});
</code></pre><p>③一次性执行(常用来写单例)    </p>
<pre><code>static dispatch_once_t onceToken;
dispatch_once(&amp;onceToken, ^{
    [self loadImageSource:imgUrl1];
});
</code></pre><p>④并发地执行循环迭代  </p>
<pre><code>dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
size_t count = 10;
dispatch_apply(count, queue, ^(size_t i) {
    NSLog(@&quot;循环执行第%li次&quot;,i);
    [self loadImageSource:imgUrl1];
});  
</code></pre><p>⑤延迟执行  </p>
<pre><code>double delayInSeconds = 2.0;
dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, delayInSeconds * NSEC_PER_SEC);
dispatch_after(popTime, dispatch_get_main_queue(), ^(void){
    [self loadImageSource:imgUrl1];
});  
</code></pre><p>⑥自定义dispatch_queue_t</p>
<pre><code>dispatch_queue_t urls_queue = dispatch_queue_create(&quot;minggo.app.com&quot;, NULL);
dispatch_async(urls_queue, ^{
    [self loadImageSource:imgUrl1];
});
</code></pre><p><strong>4.3）对比多任务执行</strong><br>异步加载图片是大部分app都要问题，那么加载图片是按循序加载完之后才刷新UI呢？还是不安顺序加载UI呢？显然大部分的希望各自加载各自的图片，各自刷新。以下就是模拟这两种场景。</p>
<p>①先后执行，加载两张图片为例    </p>
<pre><code>dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{

    UIImage *image1 = [self loadImage:imgUrl1];
    UIImage *image2 = [self loadImage:imgUrl2];

    dispatch_async(dispatch_get_main_queue(), ^{
        self.imageview1.image = image1;
        self.imageView2.image = image2;
    });
});  
</code></pre><p>②并行队列执行，也是以加载两张图片为例  </p>
<pre><code>dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);


dispatch_async(queue, ^{

    dispatch_group_t group = dispatch_group_create();

    __block UIImage *image1 = nil;
    __block UIImage *image2 = nil;


    dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        image1 = [self loadImage:imgUrl1];
    });

    dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        image2 = [self loadImage:imgUrl2];
    });


    dispatch_group_notify(group, dispatch_get_main_queue(), ^{
        self.imageview1.image = image1;
        self.imageView2.image = image2;

    });
});
</code></pre><p>①中等到两张图片加载完成后一起刷新，②就是典型的异步并行的例子，不需要理会各自图片加载的先后问题，完成加载图片刷新UI即可。从加载图片中来说，第①种不太合适使用，但是对于在上边场景选择的时候的创作工具来说有很大的好处，首先得异步进行，然后异步中有得按顺序执行几个任务，比如上传章节内容。因此，我们可以灵活考虑使用这两多线程任务执行方式，实现各种场景。<br><strong>4.4）编码实现</strong><br>以上3.3的内容99%代码一样，就不提供一个稍微整体的代码了。看看下边的效果图吧。<br><strong>4.5）效果图如下</strong><br><img src="https://github.com/minggo620/iOSMutipleThread/blob/master/picture/mutiplethread3.gif?raw=true" alt="GCD多线程加载效果"> </p>
<h2 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a>源码地址</h2><h5 id="https-github-com-JosephIvon-learnGitHub-git"><a href="#https-github-com-JosephIvon-learnGitHub-git" class="headerlink" title="https://github.com/JosephIvon/learnGitHub.git"></a><strong><em><a href="https://github.com/JosephIvon/learnGitHub.git" target="_blank" rel="external">https://github.com/JosephIvon/learnGitHub.git</a></em></strong></h5>
      
    </div>

    <div>
      
        
      
    </div>

    <footer class="post-footer">
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2015/07/16/深入理解objective-c的runtime机制/" rel="next" title="深入理解Objective-C的Runtime机制">
                <i class="fa fa-chevron-left"></i> 深入理解Objective-C的Runtime机制
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2015/07/26/UIStackview浅析/" rel="prev" title="UIStackView浅析">
                UIStackView浅析 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/default_avatar.jpg"
               alt="JosephIvon" />
          <p class="site-author-name" itemprop="name">JosephIvon</p>
          <p class="site-description motion-element" itemprop="description">iOS developer</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">8</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        <div class="links-of-blogroll motion-element">
          
        </div>

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#iOS多线程技术"><span class="nav-number">1.</span> <span class="nav-text">iOS多线程技术</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#导图"><span class="nav-number">1.1.</span> <span class="nav-text">导图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基本概念"><span class="nav-number">1.2.</span> <span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多线程"><span class="nav-number">1.3.</span> <span class="nav-text">多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是多线程"><span class="nav-number">1.3.1.</span> <span class="nav-text">什么是多线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多线程的原理"><span class="nav-number">1.3.2.</span> <span class="nav-text">多线程的原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多线程的优缺点"><span class="nav-number">1.3.3.</span> <span class="nav-text">多线程的优缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#iOS-中其实目前有-4-套多线程方案，他们分别是："><span class="nav-number">1.3.4.</span> <span class="nav-text">iOS 中其实目前有 4 套多线程方案，他们分别是：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#iOS多线程对比"><span class="nav-number">1.3.5.</span> <span class="nav-text">iOS多线程对比</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用方法"><span class="nav-number">1.4.</span> <span class="nav-text">使用方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#创建线程"><span class="nav-number">1.4.0.1.</span> <span class="nav-text">创建线程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#源码地址"><span class="nav-number">1.5.</span> <span class="nav-text">源码地址</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#https-github-com-JosephIvon-learnGitHub-git"><span class="nav-number">1.5.0.0.1.</span> <span class="nav-text">https://github.com/JosephIvon/learnGitHub.git</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">JosephIvon</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  


  




<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=0.5.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=0.5.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=0.5.0"></script>
<script type="text/javascript" src="/vendors/jquery-scrollintoview/jquery.scrollintoview.min.js?v=0.5.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=0.5.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=0.5.0"></script>



  



  



  
  
  

  

  

</body>
</html>
