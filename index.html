<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.5.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.5.0" />






<meta name="description" content="iOS developer">
<meta property="og:type" content="website">
<meta property="og:title" content="凡文波的个人博客">
<meta property="og:url" content="https://JosephIvon.github.io/index.html">
<meta property="og:site_name" content="凡文波的个人博客">
<meta property="og:description" content="iOS developer">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="凡文波的个人博客">
<meta name="twitter:description" content="iOS developer">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> 凡文波的个人博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">凡文波的个人博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">最怕一生碌碌无为，却自欺欺人平凡可贵。</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/07/16/深入理解objective-c的runtime机制/" itemprop="url">
                  深入理解Objective-C的Runtime机制
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-07-16T23:22:53+08:00" content="2015-07-16">
              2015-07-16
            </time>
          </span>

          

          
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#深入理解Objective-C的Runtime机制</p>
<h2 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h2><p>Objective-C是基于C语言加入了面向对象特性和消息转发机制的动态语言，这意味着它不仅需要一个编译器，还需要<em>runtime</em>系统来动态创建类和对象，进行消息发送和转发。下面通过分析Apple开源的<a href="http://opensource.apple.com/tarballs/objc4/" target="_blank" rel="external"><strong>Runtime代码</strong></a>（我使用的版本是objc4-646.tar）来深入理解Objective-C的<em>runtime</em>机制。</p>
<h2 id="动态-vs-静态语言"><a href="#动态-vs-静态语言" class="headerlink" title="动态 vs 静态语言"></a>动态 vs 静态语言</h2><p>Objective-C 是面相运行时的语言（<em>runtime oriented language</em>），就是说它会尽可能的把编译和链接时要执行的逻辑延迟到运行时。这就给了你很大的灵活性，你可以按需要把消息重定向给合适的对象，你甚至可以交换方法的实现，等等（译注：在 Objective-C 中调用一个对象的方法可以看成向一个对象发送消息, <strong>Method Swizzling</strong> 具体实现可以参看 <a href="https://github.com/rentzsch/jrswizzle" target="_blank" rel="external">jrswizzle</a>。这就需要使用 <em>runtime</em>，<em>runtime</em> 可以做对象自省查看他们正在做的和不能做的（<em>don’t respond to</em>）并且合适的分发消息（译注：感兴趣的同学可以查看 NSObject 类的 <code>– forwardingTargetForSelector:</code> 和 <code>– forwardInvocation:</code> 方法。(PS:不是 NSObject 协议）。如果我们和 C 这样的语言对比。在 C 里，你从 <code>main()</code> 方法开始写然后就是从上到下的写逻辑了并按你写代码的顺序执行程序。一个 C 的结构体不能转发函数执行请求到其他的目标上（<em>other targets</em>）。很可能你的程序是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &lt; stdio.h &gt;</span><br><span class="line">int main(int argc, const char **argv[])</span><br><span class="line">&#123;        </span><br><span class="line">    printf(&quot;Hello World!&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译器解析，优化然后把优化后的代码转成汇编：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line"> .align 4,0x90</span><br><span class="line"> .globl _main</span><br><span class="line">_main:</span><br><span class="line">Leh_func_begin1:</span><br><span class="line"> pushq %rbp</span><br><span class="line">Llabel1:</span><br><span class="line"> movq %rsp, %rbp</span><br><span class="line">Llabel2:</span><br><span class="line"> subq $16, %rsp</span><br><span class="line">Llabel3:</span><br><span class="line"> movq %rsi, %rax</span><br><span class="line"> movl %edi, %ecx </span><br><span class="line"> movl %ecx, -8(%rbp)</span><br><span class="line"> movq %rax, -16(%rbp) </span><br><span class="line"> xorb %al, %al </span><br><span class="line"> leaq LC(%rip), %rcx </span><br><span class="line"> movq %rcx, %rdi </span><br><span class="line"> call _printf </span><br><span class="line"> movl $0, -4(%rbp) </span><br><span class="line"> movl -4(%rbp), %eax </span><br><span class="line"> addq $16, %rsp </span><br><span class="line"> popq %rbp </span><br><span class="line"> ret</span><br><span class="line">Leh_func_end1: </span><br><span class="line"> .cstring</span><br><span class="line">LC: </span><br><span class="line"> .asciz &quot;Hello World!&quot;</span><br></pre></td></tr></table></figure>
<p>然后链接库并生成可执行程序（译注：如果你对 C 的编译链接过程还不熟悉可以参看 <a href="http://vdisk.weibo.com/s/G-kaugh74rPp" target="_blank" rel="external"><strong>Deep C and C++</strong></a>）。要和 Objective-C 对比的话，处理过程很相似，生成的代码依赖于是否有 Objective-C <em>Runtime</em> 库。当刚学 Objective-C 时，我们最先了解的(最简单的那种)是 Objective-C 中用括号包起来的代码像这样:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self doSomethingWithVar:var1];</span><br></pre></td></tr></table></figure>
<p>被转换为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSend(self,@selector(doSomethingWithVar:),var1);</span><br></pre></td></tr></table></figure>
<h2 id="Runtime数据结构"><a href="#Runtime数据结构" class="headerlink" title="Runtime数据结构"></a>Runtime数据结构</h2><p>在Objective-C中，使用 <code>[receiver message]</code> 语法并不会马上执行<strong>receiver</strong>对象的 <strong>message</strong> 方法的代码，而是向 <strong>receiver</strong> 发送一条 <strong>message</strong> 消息，这条消息可能由 <strong>receiver</strong> 来处理，也可能由转发给其他对象来处理，也有可能假装没有接收到这条消息而没有处理。其实 <code>[receiver message]</code> 被编译器转化为：</p>
<pre><code>id objc_msgSend ( id self, SEL op, ... );
</code></pre><p>下面从两个数据结构 <strong>id</strong> 和 <strong>SEL</strong> 来逐步分析和理解<em>Runtime</em>有哪些重要的数据结构。</p>
<h3 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a>SEL</h3><p><strong>SEL</strong>是函数<strong>objc_msgSend</strong>第二个参数的数据类型，表示方法选择器，按下面路径打开 <code>objc.h</code> 文件：</p>
<p><img src="http://ww4.sinaimg.cn/large/762694bagw1f46k2f38dkj20fa014jr8.jpg" alt=""></p>
<p>查看到SEL数据结构如下：</p>
<pre><code>typedef struct objc_selector *SEL;
</code></pre><p>其实它就是映射到方法的C字符串，你可以通过Objc编译器命令 <strong>@selector()</strong> 或者<em>Runtime</em>系统的 <strong>sel_registerName</strong> 函数来获取一个SEL类型的方法选择器。</p>
<p>如果你知道 <strong>selector</strong> 对应的方法名是什么，可以通过 <strong>NSString* NSStringFromSelector(SEL aSelector)</strong> 方法将<strong>SEL</strong>转化为字符串，再用<strong>NSLog</strong>打印。</p>
<h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><p>接下来看<strong>objc_msgSend</strong>第一个参数的数据类型<strong>id</strong>，<strong>id</strong>是通用类型指针，能够表示任何对象。按下面路径打开 <code>objc.h</code> 文件：</p>
<p><img src="http://ww4.sinaimg.cn/large/762694bagw1f46k2f38dkj20fa014jr8.jpg" alt=""></p>
<p>查看到<strong>id</strong>数据结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- /// Represents an instance of a class.</span><br><span class="line">- struct objc_object &#123;</span><br><span class="line">-     Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">- &#125;;</span><br><span class="line">-</span><br><span class="line">- /// A pointer to an instance of a class.</span><br><span class="line">- typedef struct objc_object *id;</span><br><span class="line">`</span><br></pre></td></tr></table></figure>
<p><strong>id</strong>其实就是一个指向<strong>objc_object</strong>结构体指针，它包含一个<strong>Class isa</strong>成员，根据<strong>isa</strong>指针就可以顺藤摸瓜找到对象所属的类。</p>
<p>注意：根据Apple的官方文档<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOImplementation.html" target="_blank" rel="external">Key-Value Observing Implementation Details</a>提及，<strong>key-value observing</strong>是使用<strong>isa-swizzling</strong>的技术实现的，<strong>isa</strong>指针在运行时被修改，指向一个中间类而不是真正的类。所以，你不应该使用<strong>isa</strong>指针来确定类的关系，而是使用<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Protocols/NSObject_Protocol/index.html#//apple_ref/occ/intfm/NSObject/class" target="_blank" rel="external"><strong>class</strong></a>方法来确定实例对象的类。</p>
<h3 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h3><p><strong>isa</strong>指针的数据类型是<strong>Class</strong>，<strong>Class</strong>表示对象所属的类，按下面路径打开 <code>objc.h</code> 文件：</p>
<p><img src="http://ww4.sinaimg.cn/large/762694bagw1f46k2f38dkj20fa014jr8.jpg" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- /// An opaque type that represents an Objective-C class.</span><br><span class="line">- typedef struct objc_class *Class;</span><br></pre></td></tr></table></figure>
<p>可以查看到<strong>Class</strong>其实就是一个<strong>objc_class</strong>结构体指针，但这个头文件找不到它的定义，需要在 <code>runtime.h</code> 才能找到<strong>objc_class</strong>结构体的定义。</p>
<p>按下面路径打开 <code>runtime.h</code> 文件：</p>
<p><img src="http://ww4.sinaimg.cn/large/762694bagw1f46k2f38dkj20fa014jr8.jpg" alt=""></p>
<p>查看到<strong>objc_class</strong>结构体定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- struct objc_class &#123;</span><br><span class="line">-     Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">-</span><br><span class="line">- #if !__OBJC2__</span><br><span class="line">-     Class super_class                                        OBJC2_UNAVAILABLE;</span><br><span class="line">-     const char *name                                         OBJC2_UNAVAILABLE;</span><br><span class="line">-     long version                                             OBJC2_UNAVAILABLE;</span><br><span class="line">-     long info                                                OBJC2_UNAVAILABLE;</span><br><span class="line">-     long instance_size                                       OBJC2_UNAVAILABLE;</span><br><span class="line">-     struct objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;</span><br><span class="line">-     struct objc_method_list **methodLists                    OBJC2_UNAVAILABLE;</span><br><span class="line">-     struct objc_cache *cache                                 OBJC2_UNAVAILABLE;</span><br><span class="line">-     struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;</span><br><span class="line">- #endif</span><br><span class="line">-</span><br><span class="line">- &#125; OBJC2_UNAVAILABLE;</span><br><span class="line">- /* Use `Class` instead of `struct objc_class *` */</span><br></pre></td></tr></table></figure>
<pre><code>注意：OBJC2_UNAVAILABLE是一个Apple对Objc系统运行版本进行约束的宏定义，主要为了兼容非Objective-C 2.0的遗留版本，但我们仍能从中获取一些有用信息。
</code></pre><p>让我们分析一些重要的成员变量表示什么意思和对应使用哪些数据结构。</p>
<p><strong>isa</strong>表示一个<strong>Class</strong>对象的<strong>Class</strong>，也就是<strong>Meta Class</strong>。在面向对象设计中，一切都是对象，<strong>Class</strong>在设计中本身也是一个对象。我们会在 <code>objc-runtime-new.h</code> 文件找到证据，发现<strong>objc_class</strong>有以下定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- struct objc_class : objc_object &#123;</span><br><span class="line">-   // Class ISA;</span><br><span class="line">-   Class superclass;</span><br><span class="line">-   cache_t cache;             // formerly cache pointer and vtable</span><br><span class="line">-   class_data_bits_t bits;    // class_rw_t * plus custom rr/alloc flags</span><br><span class="line">-</span><br><span class="line">-   ......</span><br><span class="line">- &#125;</span><br></pre></td></tr></table></figure>
<p>由此可见，结构体<strong>objc_class</strong>也是继承<strong>objc_object</strong>，说明<strong>Class</strong>在设计中本身也是一个对象。<br>其实<strong>Meta Class</strong>也是一个<strong>Class</strong>，那么它也跟其他<strong>Class</strong>一样有自己的<strong>isa</strong>和<strong>super_class</strong>指针，关系如下：</p>
<p><img src="http://ww4.sinaimg.cn/large/762694bagw1f46l0mgp59j20e00ep75m.jpg" alt=""></p>
<p>上图实线是<strong>super_class</strong>指针，虚线是<strong>isa</strong>指针。有几个关键点需要解释以下：<br></p>
<ul>
<li>1、<strong>Root class (class)</strong>其实就是<strong>NSObject</strong>，<strong>NSObject</strong>是没有超类的，所以<strong>Root class(class)</strong>的<strong>superclass</strong>指向<strong>nil</strong>.<br></li>
<li>2、每个<strong>Class</strong>都有一个<strong>isa</strong>指针指向唯一的<strong>Meta class</strong>.<br></li>
<li>3、<strong>Root class(meta)</strong>的<strong>superclass</strong>指向<strong>Root class(class)</strong>，也就是<strong>NSObject</strong>，形成一个回路.<br></li>
<li><p>4、每个<strong>Meta class</strong>的<strong>isa</strong>指针都指向<strong>Root class (meta)</strong>.<br></p>
</li>
<li><p><strong>super_class</strong>表示实例对象对应的父类；</p>
</li>
<li><strong>name</strong>表示类名；</li>
<li><strong>ivars</strong>表示多个成员变量，它指向<strong>objc_ivar_list</strong>结构体。在 <code>runtime.h</code> 可以看到它的定义：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- struct objc_ivar_list &#123;</span><br><span class="line">-   int ivar_count                                           OBJC2_UNAVAILABLE;</span><br><span class="line">- #ifdef __LP64__</span><br><span class="line">-   int space                                                OBJC2_UNAVAILABLE;</span><br><span class="line">- #endif</span><br><span class="line">-   /* variable length structure */</span><br><span class="line">-   struct objc_ivar ivar_list[1]                            OBJC2_UNAVAILABLE;</span><br><span class="line">- &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>objc_ivar_list</strong>其实就是一个链表，存储多个<strong>objc_ivar</strong>，而<strong>objc_ivar</strong>结构体存储类的单个成员变量信息。<br></li>
<li><strong>methodLists</strong>表示方法列表，它指向<strong>objc_method_list</strong>结构体的二级指针，可以动态修改<em>methodLists的值来添加成员方法，也是<strong>Category</strong>实现原理，同样也解释<em>*Category</em></em>不能添加属性的原因。在 <code>runtime.h</code> 可以看到它的定义：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- struct objc_method_list &#123;</span><br><span class="line">-   struct objc_method_list *obsolete                        OBJC2_UNAVAILABLE;</span><br><span class="line">-</span><br><span class="line">-   int method_count                                         OBJC2_UNAVAILABLE;</span><br><span class="line">- #ifdef __LP64__</span><br><span class="line">-   int space                                                OBJC2_UNAVAILABLE;</span><br><span class="line">- #endif</span><br><span class="line">-   /* variable length structure */</span><br><span class="line">-   struct objc_method method_list[1]                        OBJC2_UNAVAILABLE;</span><br><span class="line">- &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>同理，<strong>objc_method_list</strong>也是一个链表，存储多个<strong>objc_method</strong>，而<strong>objc_method</strong>结构体存储类的某个方法的信息。</p>
</li>
<li><p><strong>cache</strong>用来缓存经常访问的方法，它指向<strong>objc_cache</strong>结构体，后面会重点讲到。</p>
</li>
<li><strong>protocols</strong>表示类遵循哪些协议。</li>
</ul>
<h3 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h3><p><strong>Method</strong>表示类中的某个方法，在 <code>runtime.h</code> 文件中找到它的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- /// An opaque type that represents a method in a class definition.</span><br><span class="line">- typedef struct objc_method *Method;</span><br><span class="line">- struct objc_method &#123;</span><br><span class="line">-     SEL method_name                                          OBJC2_UNAVAILABLE;</span><br><span class="line">-     char *method_types                                       OBJC2_UNAVAILABLE;</span><br><span class="line">-     IMP method_imp                                           OBJC2_UNAVAILABLE;</span><br><span class="line">- &#125;</span><br></pre></td></tr></table></figure>
<p>其实<strong>Method</strong>就是一个指向<strong>objc_method</strong>结构体指针，它存储了方法名(<em>method_name</em>)、方法类型(<em>method_types</em>)和方法实现(<em>method_imp</em>)等信息。而<em>method_imp</em>的数据类型是<strong>IMP</strong>，它是一个函数指针，后面会重点提及。</p>
<h3 id="Ivar"><a href="#Ivar" class="headerlink" title="Ivar"></a>Ivar</h3><p><strong>Ivar</strong>表示类中的实例变量，在 <code>runtime.h</code> 文件中找到它的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- /// An opaque type that represents an instance variable.</span><br><span class="line">- typedef struct objc_ivar *Ivar;</span><br><span class="line">-</span><br><span class="line">- struct objc_ivar &#123;</span><br><span class="line">-     char *ivar_name                                          OBJC2_UNAVAILABLE;</span><br><span class="line">-     char *ivar_type                                          OBJC2_UNAVAILABLE;</span><br><span class="line">-     int ivar_offset                                          OBJC2_UNAVAILABLE;</span><br><span class="line">- #ifdef __LP64__</span><br><span class="line">-     int space                                                OBJC2_UNAVAILABLE;</span><br><span class="line">- #endif</span><br><span class="line">- &#125;</span><br></pre></td></tr></table></figure>
<p><strong>Ivar</strong>其实就是一个指向<strong>objc_ivar</strong>结构体指针，它包含了变量名(<em>ivar_name</em>)、变量类型(<em>ivar_type</em>)等信息。</p>
<h3 id="IMP"><a href="#IMP" class="headerlink" title="IMP"></a>IMP</h3><p>在上面讲<strong>Method</strong>时就说过，<strong>IMP</strong>本质上就是一个函数指针，指向方法的实现，在 <code>objc.h</code> 找到它的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    - /// A pointer to the function of a method implementation.</span><br><span class="line">    - #if !OBJC_OLD_DISPATCH_PROTOTYPES</span><br><span class="line">    - typedef void (*IMP)(void /* id, SEL, ... */ );</span><br><span class="line">    - #else</span><br><span class="line">    - typedef id (*IMP)(id, SEL, ...);</span><br><span class="line">    - #endif</span><br><span class="line">```    </span><br><span class="line">当你向某个对象发送一条信息，可以由这个函数指针来指定方法的实现，它最终就会执行那段代码，这样可以绕开消息传递阶段而去执行另一个方法实现。</span><br><span class="line"></span><br><span class="line">### Cache</span><br><span class="line">顾名思义，**Cache**主要用来缓存，那它缓存什么呢？我们先在 `runtime.h` 文件看看它的定义：</span><br></pre></td></tr></table></figure>
<pre><code>- typedef struct objc_cache *Cache                             OBJC2_UNAVAILABLE;
-
- struct objc_cache {
-     unsigned int mask /* total = mask + 1 */                 OBJC2_UNAVAILABLE;
-     unsigned int occupied                                    OBJC2_UNAVAILABLE;
-     Method buckets[1]                                        OBJC2_UNAVAILABLE;
- };
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">**Cache**其实就是一个存储**Method**的链表，主要是为了优化方法调用的性能。当对象**receiver**调用方法**message**时，首先根据对象**receiver**的**isa**指针查找到它对应的类，然后在类的**methodLists**中搜索方法，如果没有找到，就使用**super_class**指针到父类中的**methodLists**查找，一旦找到就调用方法。如果没有找到，有可能消息转发，也可能忽略它。但这样查找方式效率太低，因为往往一个类大概只有20%的方法经常被调用，占总调用次数的80%。所以使用**Cache**来缓存经常调用的方法，当调用方法时，优先在**Cache**查找，如果没有找到，再到**methodLists**查找。</span><br><span class="line"></span><br><span class="line">## 消息发送</span><br><span class="line">前面从**objc_msgSend**作为入口，逐步深入分析*Runtime*的数据结构，了解每个数据结构的作用和它们之间关系后，我们正式转入消息发送这个正题。&lt;br/&gt;</span><br><span class="line"></span><br><span class="line">**objc_msgSend函数**&lt;br/&gt;</span><br><span class="line">在前面已经提过，当某个对象使用语法 `[receiver message]` 来调用某个方法时，其实 `[receiver message]` 被编译器转化为：</span><br></pre></td></tr></table></figure>
<pre><code>- id objc_msgSend ( id self, SEL op, ... );
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">- 现在让我们看一下**objc_msgSend**它具体是如何发送消息：</span><br><span class="line"></span><br><span class="line">  - 1、首先根据**receiver**对象的**isa**指针获取它对应的**class**；</span><br><span class="line">  - 2、优先在**class的cache**查找**message**方法，如果找不到，再到**methodLists**查找；</span><br><span class="line">  - 3、如果没有在**class**找到，再到**super_class**查找；</span><br><span class="line">  - 4、一旦找到**message**这个方法，就执行它实现的**IMP**。</span><br><span class="line"></span><br><span class="line">![](http://ww2.sinaimg.cn/large/762694bagw1f46lsvffshj20980f474x.jpg)</span><br><span class="line"></span><br><span class="line">### self与super</span><br><span class="line">为了让大家更好地理解self和super，借用[sunnyxx博客](http://blog.sunnyxx.com)的[iOS程序员6级考试](http://blog.sunnyxx.com/2014/03/06/ios_exam_0_key/)一道题目：下面的代码分别输出什么？</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        - @implementation Son : Father</span><br><span class="line">        - - (id)init</span><br><span class="line">        - &#123;</span><br><span class="line">        -     self = [super init];</span><br><span class="line">        -     if (self)</span><br><span class="line">        -     &#123;</span><br><span class="line">        -         NSLog(@&quot;%@&quot;, NSStringFromClass([self class]));</span><br><span class="line">        -         NSLog(@&quot;%@&quot;, NSStringFromClass([super class]));</span><br><span class="line">        -     &#125;</span><br><span class="line">        -     return self;</span><br><span class="line">        - &#125;</span><br><span class="line">        - @end</span><br><span class="line"></span><br><span class="line">**self**表示当前这个类的对象，而**super**是一个编译器标示符，和**self**指向同一个消息接受者。在本例中，无论是 `[self class]` 还是 `[super class]` ，接受消息者都是**Son**对象，但**super**与**self**不同的是，**self**调用**class**方法时，是在子类**Son**中查找方法，而**super**调用**class**方法时，是在父类**Father**中查找方法。&lt;br/&gt;</span><br><span class="line">当调用 `[self class]` 方法时，会转化为**objc_msgSend**函数，这个函数定义如下：</span><br><span class="line"></span><br><span class="line">        - id objc_msgSend(id self, SEL op, ...)</span><br><span class="line">        </span><br><span class="line">这时会从当前**Son**类的方法列表中查找，如果没有，就到**Father**类查找，还是没有，最后在**NSObject**类查找到。</span><br><span class="line"></span><br><span class="line">我们可以从 `NSObject.mm` 文件中看到 `- (Class)class` 的实现：</span><br></pre></td></tr></table></figure>
<ul>
<li><p>(Class)class {<br>return object_getClass(self);<br>}<br><code>``
所以</code>NSLog(@”%@”, NSStringFromClass([self class]));<code>会输出</code>Son<code>。&lt;br/&gt;
当调用</code>[super class]` 方法时，会转化为<strong>objc_msgSendSuper</strong>，这个函数定义如下：<br></p>
<ul>
<li>id objc_msgSendSuper(struct objc_super *super, SEL op, …)</li>
</ul>
</li>
</ul>
<p><strong>objc_msgSendSuper</strong>函数第一个参数<strong>super</strong>的数据类型是一个指向<strong>objc_super</strong>的结构体，从 <code>message.h</code> 文件中查看它的定义：</p>
<pre><code>/// Specifies the superclass of an instance.
struct objc_super {
    /// Specifies an instance of a class.
    __unsafe_unretained id receiver;

    /// Specifies the particular superclass of the instance to message.
#if !defined(__cplusplus)  &amp;&amp;  !__OBJC2__
    /* For compatibility with old objc-runtime.h header */
    __unsafe_unretained Class class;
#else
    __unsafe_unretained Class super_class;
#endif
    /* super_class is the first class to search */
};
#endif
</code></pre><p>结构体包含两个成员，第一个是<strong>receiver</strong>，表示某个类的实例。第二个是<strong>super_class</strong>表示当前类的父类。</p>
<p>这时首先会构造出<strong>objc_super</strong>结构体，这个结构体第一个成员是<strong>self</strong>，第二个成员是<strong>(id)class_getSuperclass(objc_getClass(“Son”))</strong>，实际上该函数会输出<strong>Father</strong>。然后在<strong>Father</strong>类查找<strong>class</strong>方法，查找不到，最后在<strong>NSObject</strong>查到。此时，内部使用<strong>objc_msgSend(objc_super-&gt;receiver</strong>, <strong>@selector(class))</strong>去调用，与 <code>[self class]</code> 调用相同，所以结果还是<strong>Son</strong>。</p>
<h3 id="隐藏参数self和-cmd"><a href="#隐藏参数self和-cmd" class="headerlink" title="隐藏参数self和_cmd"></a>隐藏参数self和_cmd</h3><p>当 <code>[receiver message]</code> 调用方法时，系统会在运行时偷偷地动态传入两个隐藏参数<strong>self</strong>和<strong>_cmd</strong>，之所以称它们为隐藏参数，是因为在源代码中没有声明和定义这两个参数。至于对于<strong>self</strong>的描述，上面已经解释非常清楚了，下面我们重点讲解<strong>_cmd</strong>。</p>
<p><strong>_cmd</strong>表示当前调用方法，其实它就是一个方法选择器<strong>SEL</strong>。一般用于判断方法名或在<strong>Associated Objects</strong>中唯一标识键名，后面在<strong>Associated Objects</strong>会讲到。</p>
<h2 id="方法解析与消息转发"><a href="#方法解析与消息转发" class="headerlink" title="方法解析与消息转发"></a>方法解析与消息转发</h2><p> <code>[receiver message]</code> 调用方法时，如果在<strong>message</strong>方法在<strong>receiver</strong>对象的类继承体系中没有找到方法，那怎么办？一般情况下，程序在运行时就会<strong>Crash</strong>掉，抛出  <code>unrecognized selector sent to…</code> 类似这样的异常信息。但在抛出异常之前，还有三次机会按以下顺序让你拯救程序。</p>
<ul>
<li>1.Method Resolution</li>
<li>2.Fast Forwarding</li>
<li>3.Normal Forwarding</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/762694bagw1f46m8x0bpmj20fa0cfmxa.jpg" alt=""></p>
<h3 id="Method-Resolution"><a href="#Method-Resolution" class="headerlink" title="Method Resolution"></a>Method Resolution</h3><p>首先Objective-C在运行时调用 <code>+ resolveInstanceMethod:</code> 或 <code>+ resolveClassMethod:</code> 方法，让你添加方法的实现。如果你添加方法并返回YES，那系统在运行时就会重新启动一次消息发送的过程。<br>举一个简单例子，定义一个类<strong>Message</strong>，它主要定义一个方法<strong>sendMessage</strong>，下面就是它的设计与实现：<br></p>
<pre><code>@interface Message : NSObject
- (void)sendMessage:(NSString *)word;
@end

@implementation Message
- (void)sendMessage:(NSString *)word
{
    NSLog(@&quot;normal way : send message = %@&quot;, word);
}
@end
</code></pre><p>如果我 <code>viewDidLoad</code> 方法中创建<strong>Message</strong>对象并调用 <code>sendMessage</code> 方法：<br></p>
<pre><code>- (void)viewDidLoad {
    [super viewDidLoad];
    Message *message = [Message new];
    [message sendMessage:@&quot;Sam Lau&quot;];
}
</code></pre><p>控制台会打印以下信息：</p>
<pre><code>normal way : send message = Sam Lau
</code></pre><p>但现在我将原来 <code>sendMessage</code> 方法实现给注释掉，覆盖 <code>resolveInstanceMethod</code> 方法：</p>
<pre><code>#pragma mark - Method Resolution
/// override resolveInstanceMethod or resolveClassMethod for changing sendMessage method implementation
+ (BOOL)resolveInstanceMethod:(SEL)sel
{
    if (sel == @selector(sendMessage:)) {
        class_addMethod([self class], sel, imp_implementationWithBlock(^(id self, NSString *word) {
            NSLog(@&quot;method resolution way : send message = %@&quot;, word);
        }), &quot;v@*&quot;);
    }
    return YES;
}
</code></pre><p>控制台就会打印以下信息：</p>
<pre><code>method resolution way : send message = Sam Lau
</code></pre><p>注意到上面代码有这样一个字符串”v@*，它表示方法的参数和返回值，详情请参考<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1" target="_blank" rel="external">Type Encodings</a>。</p>
<p>如果 <code>resolveInstanceMethod</code> 方法返回NO，运行时就跳转到下一步：消息转发(<em>Message Forwarding</em>)。</p>
<h3 id="Fast-Forwarding"><a href="#Fast-Forwarding" class="headerlink" title="Fast Forwarding"></a>Fast Forwarding</h3><p>如果目标对象实现 <code>- forwardingTargetForSelector:</code> 方法，系统就会在运行时调用这个方法，只要这个方法返回的不是<strong>nil</strong>或<strong>self</strong>，也会重启消息发送的过程，把这消息转发给其他对象来处理。否则，就会继续 <code>Normal Fowarding</code> 。</p>
<p>继续上面<strong>Message</strong>类的例子，将 <code>sendMessage</code> 和 <code>resolveInstanceMethod</code> 方法注释掉，然后添加 <code>forwardingTargetForSelector</code> 方法的实现：</p>
<pre><code>#pragma mark - Fast Forwarding
- (id)forwardingTargetForSelector:(SEL)aSelector
{
    if (aSelector == @selector(sendMessage:)) {
        return [MessageForwarding new];
    }
    return nil;
}
</code></pre><p>此时还缺一个转发消息的类<strong>MessageForwarding</strong>，这个类的设计与实现如下：</p>
<pre><code>@interface MessageForwarding : NSObject
- (void)sendMessage:(NSString *)word;
@end

@implementation MessageForwarding
- (void)sendMessage:(NSString *)word
{
    NSLog(@&quot;fast forwarding way : send message = %@&quot;, word);
}
@end
</code></pre><p>此时，控制台会打印以下信息：</p>
<pre><code>fast forwarding way : send message = Sam Lau
</code></pre><p>这里叫<strong>Fast</strong>，是因为这一步不会创建<strong>NSInvocation</strong>对象，但 <code>Normal Forwarding</code> 会创建它，所以相对于更快点。</p>
<h3 id="Normal-Forwarding"><a href="#Normal-Forwarding" class="headerlink" title="Normal Forwarding"></a>Normal Forwarding</h3><p>如果没有使用 <code>Fast Forwarding</code> 来消息转发，最后只有使用 <code>Normal Forwarding</code> 来进行消息转发。它首先调用 <code>methodSignatureForSelector:</code> 方法来获取函数的参数和返回值，如果返回为<strong>nil</strong>，程序会<strong>Crash</strong>掉，并抛出 <code>unrecognized selector sent to instance</code> 异常信息。如果返回一个函数签名，系统就会创建一个<strong>NSInvocation</strong>对象并调用 <code>-forwardInvocation:</code> 方法。</p>
<p>继续前面的例子，将 <code>forwardingTargetForSelector</code> 方法注释掉，添加 <code>methodSignatureForSelector</code> 和 <code>forwardInvocation</code> </p>
<p>方法的实现：</p>
<pre><code>#pragma mark - Normal Forwarding
- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector
{
    NSMethodSignature *methodSignature = [super methodSignatureForSelector:aSelector];
    if (!methodSignature) {
        methodSignature = [NSMethodSignature signatureWithObjCTypes:&quot;v@:*&quot;];
    }
    return methodSignature;
}
- (void)forwardInvocation:(NSInvocation *)anInvocation
{
    MessageForwarding *messageForwarding = [MessageForwarding new];
    if ([messageForwarding respondsToSelector:anInvocation.selector]) {
        [anInvocation invokeWithTarget:messageForwarding];
    }
}
</code></pre><p>关于这个例子的示例代码请到<a href="https://github.com/JosephIvon/learnGitHub.git" target="_blank" rel="external">Github</a>下载。</p>
<h3 id="三种方法的选择"><a href="#三种方法的选择" class="headerlink" title="三种方法的选择"></a>三种方法的选择</h3><p><em>Runtime</em>提供三种方式来将原来的方法实现代替掉，那该怎样选择它们呢？</p>
<ul>
<li><strong>Method Resolution：</strong>由于<em>Method Resolution</em>不能像消息转发那样可以交给其他对象来处理，所以只适用于在原来的类中代替掉。</li>
<li><strong>Fast Forwarding：</strong>它可以将消息处理转发给其他对象，使用范围更广，不只是限于原来的对象。</li>
<li><strong>Normal Forwarding：</strong>它跟<em>Fast Forwarding</em>一样可以消息转发，但它能通过<strong>NSInvocation</strong>对象获取更多消息发送的信息，例如：<strong>target</strong>、<strong>selector</strong>、<strong>arguments</strong>和返回值等信息。</li>
</ul>
<h3 id="Associated-Objects"><a href="#Associated-Objects" class="headerlink" title="Associated Objects"></a>Associated Objects</h3><p>当使用<strong>Category</strong>对某个类进行扩展时，有时需要存储属性，<strong>Category</strong>是不支持的，这时需要使用<strong>Associated Objects</strong>来给已存在的类<strong>Category</strong>添加自定义的属性。<strong>Associated Objects</strong>提供三个API来向对象添加、获取和删除关联值：</p>
<pre><code>- void objc_setAssociatedObject (id object, const void *key, id value, objc_AssociationPolicy policy )
- id objc_getAssociatedObject (id object, const void *key )
- void objc_removeAssociatedObjects (id object )    
</code></pre><ul>
<li>其中objc_AssociationPolicy是个枚举类型，它可以指定Objc内存管理的引用计数机制。</li>
</ul>
<pre><code>typedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) {
  OBJC_ASSOCIATION_ASSIGN = 0,           /**&lt; Specifies a weak reference to the associated object. */
  OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, /**&lt; Specifies a strong reference to the associated object.
                                          *   The association is not made atomically. */
  OBJC_ASSOCIATION_COPY_NONATOMIC = 3,   /**&lt; Specifies that the associated object is copied.
                                          *   The association is not made atomically. */
  OBJC_ASSOCIATION_RETAIN = 01401,       /**&lt; Specifies a strong reference to the associated object.
                                          *   The association is made atomically. */
  OBJC_ASSOCIATION_COPY = 01403          /**&lt; Specifies that the associated object is copied.
                                          *   The association is made atomically. */
};
</code></pre><p>下面有个关于 <code>NSObject+AssociatedObject Category</code> 添加属性 <code>associatedObject</code> 的示例代码：<br><br><strong>NSObject+AssociatedObject.h</strong></p>
<pre><code>@interface NSObject (AssociatedObject)
@property (strong, nonatomic) id associatedObject;
@end
</code></pre><p><strong>NSObject+AssociatedObject.m</strong></p>
<pre><code>@implementation NSObject (AssociatedObject)
- (void)setAssociatedObject:(id)associatedObject
{
    objc_setAssociatedObject(self, @selector(associatedObject), associatedObject, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
}
- (id)associatedObject
{
    return objc_getAssociatedObject(self, _cmd);
}
@end
</code></pre><p> <code>Associated Objects</code> 的<strong>key</strong>要求是唯一并且是常量，而<strong>SEL</strong>是满足这个要求的，所以上面的采用隐藏参数<strong>_cmd</strong>作为<strong>key</strong>。</p>
<h3 id="Method-Swizzling"><a href="#Method-Swizzling" class="headerlink" title="Method Swizzling"></a>Method Swizzling</h3><p> <code>Method Swizzling</code> 就是在运行时将一个方法的实现代替为另一个方法的实现。如果能够利用好这个技巧，可以写出简洁、有效且维护性更好的代码。可以参考两篇关于Method Swizzling技巧的文章：</p>
<ul>
<li><a href="https://github.com/JosephIvon/learnGitHub.git" target="_blank" rel="external">nshipster Method Swizzling</a></li>
<li><a href="http://tech.glowing.com/cn/method-swizzling-aop/" target="_blank" rel="external">Method Swizzling和AOP实践</a></li>
</ul>
<h3 id="Aspect-Oriented-Programming-AOP"><a href="#Aspect-Oriented-Programming-AOP" class="headerlink" title="Aspect-Oriented Programming(AOP)"></a>Aspect-Oriented Programming(AOP)</h3><p>类似记录日志、身份验证、缓存等事务非常琐碎，与业务逻辑无关，很多地方都有，又很难抽象出一个模块，这种程序设计问题，业界给它们起了一个名字叫横向关注点(<em>Cross-cutting concern</em>)，<a href="https://en.wikipedia.org/wiki/Aspect-oriented_programming" target="_blank" rel="external">AOP</a>作用就是分离横向关注点(<em>Cross-cutting concern</em>)来提高模块复用性，它可以在既有的代码添加一些额外的行为(记录日志、身份验证、缓存)而无需修改代码。</p>
<h3 id="危险性"><a href="#危险性" class="headerlink" title="危险性"></a>危险性</h3><p>Method Swizzling就像一把瑞士小刀，如果使用得当，它会有效地解决问题。但使用不当，将带来很多麻烦。在stackoverflow上有人已经提出这样一个问题：<a href="http://stackoverflow.com/questions/5339276/what-are-the-dangers-of-method-swizzling-in-objective-c" target="_blank" rel="external">What are the Dangers of Method Swizzling in Objective C?</a>，它的危险性主要体现以下几个方面：</p>
<ul>
<li>Method swizzling is not atomic</li>
<li>Changes behavior of un-owned code</li>
<li>Possible naming conflicts</li>
<li>Swizzling changes the method’s arguments</li>
<li>The order of swizzles matters</li>
<li>Difficult to understand (looks recursive)</li>
<li>Difficult to debug</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>虽然在平时项目不是经常用到Objective-C的<em>Runtime</em>特性，但当你阅读一些iOS开源项目时，你就会发现很多时候都会用到。所以深入理解Objective-C的<em>Runtime</em>数据结构、消息转发机制有助于你更容易地阅读和学习开源项目。</p>
<h4 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h4><ul>
<li><a href="http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/" target="_blank" rel="external">玉令天下博客的Objective-C Runtime</a></li>
<li><a href="http://tech.glowing.com/cn/objective-c-runtime/" target="_blank" rel="external">顾鹏博客的Objective-C Runtime</a></li>
<li><a href="http://nshipster.com/associated-objects/" target="_blank" rel="external">Associated Objects</a></li>
<li><a href="http://nshipster.com/method-swizzling/" target="_blank" rel="external">Method Swizzling</a></li>
<li><a href="http://tech.glowing.com/cn/method-swizzling-aop/" target="_blank" rel="external">Method Swizzling和AOP实践</a></li>
<li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ObjCRuntimeRef/index.html#//apple_ref/doc/uid/TP40001418" target="_blank" rel="external">Objective-C Runtime Reference</a></li>
<li><a href="">What are the Dangers of Method Swizzling in Objective C?</a></li>
<li><a href="http://blog.sunnyxx.com/2014/03/06/ios_exam_0_key/" target="_blank" rel="external">iOS程序员6级考试（答案和解释)</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/07/11/markdown常用语法/" itemprop="url">
                  Markdown常用语法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-07-11T23:44:46+08:00" content="2015-07-11">
              2015-07-11
            </time>
          </span>

          

          
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#Markdown常用语法</p>
<h2 id="什么是Markdown"><a href="#什么是Markdown" class="headerlink" title="什么是Markdown?"></a>什么是Markdown?</h2><p>  <a href="http://zh.wikipedia.org/wiki/Markdown" target="_blank" rel="external"><strong>Markdown</strong></a> 是一种用来写作的轻量级<strong>「标记语言」</strong>，它用简洁的语法代替排版，而不像一般我们用的字处理软件 Word 或 Pages 有大量的排版、字体设置。它使我们专心于码字，用「标记」语法，来代替常见的排版格式。例如此文从内容到格式，甚至插图，键盘就可以通通搞定了。目前来看，支持 Markdown 语法的编辑器有很多，包括很多网站（例如<a href="http://www.jianshu.com" target="_blank" rel="external"><strong>简书</strong></a>）也支持了 Markdown 的文字录入。<br> Markdown从写作到完成，导出格式随心所欲，你可以导出 HTML 格式的文件用来网站发布，也可以十分方便的导出 PDF 格式，这种格式写出的简历更能得到 HR 的好感。甚至可以利用 <a href="https://www.getcloudapp.com" target="_blank" rel="external"><strong>CloudApp</strong></a> 这种云服务工具直接上传至网页用来分享你的文章，全球最大的轻博客平台 <a href="http://te1ee.tumblr.com" target="_blank" rel="external"><strong>Tumblr</strong></a> ，也支持使用 <strong>Mou</strong> 这类Markdown工具进行编辑并直接上传。 </p>
<h2 id="Markdown-官方文档"><a href="#Markdown-官方文档" class="headerlink" title="Markdown 官方文档"></a>Markdown 官方文档</h2><ul>
<li><a href="http://daringfireball.net/projects/markdown/syntax" target="_blank" rel="external"><em>创始人 John Gruber 的 Markdown 语法说明</em></a></li>
<li><a href="http://wowubuntu.com/markdown/#list" target="_blank" rel="external"><em>Markdown 中文版语法说明</em></a></li>
</ul>
<p>##使用 Markdown 的优点</p>
<ul>
<li>专注你的文字内容而不是排版样式。</li>
<li>轻松的导出 HTML、PDF 和本身的 .md 文件。</li>
<li>纯文本内容，兼容所有的文本编辑器与字处理软件。</li>
<li>可读，直观。适合所有人的写作语言。</li>
</ul>
<p>##常用工具<br><img src="http://cdn.sspai.com/attachment/thumbnail/2014/04/15/54b0855cf47d559c8c59e8f503af17d410f70_mw_800_wm_1_wmp_3.jpg" alt=""></p>
<p>##Mac 平台</p>
<ul>
<li>在 <strong>Mac OS X</strong> 上，建议使用 <a href="http://25.io/mou/" target="_blank" rel="external"><strong>Mou</strong></a> 这款免费且十分好用的 <strong>Markdown</strong> 编辑器，它支持实时预览，既左边是你编辑 <strong>Markdow</strong>n 语言，右边会实时的生成预览效果。不仅如此，<strong>Mou</strong> 还有一些有趣的偏好设置（<strong><em>Preference</em></strong>），例如主题（<strong><em>Themes</em></strong>）与样式（<strong><em>CSS</em></strong>），它们可以配置出定制化的文本编辑效果与导出效果，如果你对自带的主题与样式不满意还可以到 <a href="https://github.com/search?utf8=✓&amp;q=Mou" target="_blank" rel="external"><strong>GitHub</strong></a> 上搜索其它爱好者为 <strong>Mou</strong> 编写的更多主题样式，导入的方式可以在偏好设置的 <strong><em>Themes</em></strong> 或 <strong><em>CSS</em></strong> 选项中 选择 <strong>reload</strong>。</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/6aee7dbbgw1effcq2gx92j210j0ustj7.jpg" alt=""></p>
<h2 id="Markdown-语法的简要规则"><a href="#Markdown-语法的简要规则" class="headerlink" title="Markdown 语法的简要规则"></a>Markdown 语法的简要规则</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p><img src="http://ww1.sinaimg.cn/large/6aee7dbbgw1effeaclhiyj20eh09cwez.jpg" alt=""></p>
<p>标题是每篇文章都需要也是最常用的格式，在 Markdown 中，如果一段文字被定义为标题，只要在这段文字前加 <code>#</code>号即可。</p>
<p><code># 一级标题</code></p>
<p><code>## 二级标题</code></p>
<p><code>### 三级标题</code></p>
<p>以此类推，总共六级标题，建议在井号后加一个空格，这是最标准的 <strong>Markdown</strong> 语法。</p>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>熟悉 <strong>HTML</strong> 的同学肯定知道有序列表与无序列表的区别，在 <strong>Markdown</strong> 下，列表的显示只需要在文字前加上 <code>-</code> 或 <code>*</code> 即可变为无序列表，有序列表则直接在文字前加<code>1.</code> <code>2.</code>  <code>3.</code> 符号要和文字之间加上一个字符的空格。<br><img src="http://ww4.sinaimg.cn/large/6aee7dbbgw1effew5aftij20d80bz3yw.jpg" alt=""></p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>如果你需要引用一小段别处的句子，那么就要用引用的格式。<br><img src="http://ww3.sinaimg.cn/large/6aee7dbbgw1effezhonxlj20e009c3yu.jpg" alt=""></p>
<p>图片与链接<br>插入链接与插入图片的语法很像，区别在一个 <code>!</code> 号</p>
<p>图片为：<code>![](){ImgCap}{/ImgCap}</code></p>
<p>链接为：<code>[]()</code></p>
<p>插入图片的地址需要图床，这里推荐 <a href="http://weibotuchuang.sinaapp.com" target="_blank" rel="external"><strong>围脖图床修复计划</strong></a> 与 <a href="https://www.getcloudapp.com" target="_blank" rel="external"><strong>CloudApp</strong></a> 的服务，生成URL地址即可。</p>
<h3 id="粗体与斜体"><a href="#粗体与斜体" class="headerlink" title="粗体与斜体"></a>粗体与斜体</h3><p><strong>Markdown</strong> 的粗体和斜体也非常简单，用两个 <code>*</code> 包含一段文本就是粗体的语法，用一个 <code>*</code> 包含一段文本就是斜体的语法。</p>
<p>例如：<strong>这里是粗体</strong> <em>这里是斜体</em> <br><br>粗体快捷键 <code>Command + B</code>   斜体快捷键 <code>Command + I</code></p>
<h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p>表格是我觉得 <strong>Markdown</strong> 比较累人的地方，例子如下：<br></p>
<table>
<thead>
<tr>
<th>Tables</th>
<th style="text-align:center">Are</th>
<th style="text-align:right">Cool</th>
</tr>
</thead>
<tbody>
<tr>
<td>col 3 is</td>
<td style="text-align:center">right-aligned</td>
<td style="text-align:right">$1600</td>
</tr>
<tr>
<td>col 2 is</td>
<td style="text-align:center">centered</td>
<td style="text-align:right">$12</td>
</tr>
<tr>
<td>zebra stripes</td>
<td style="text-align:center">are neat</td>
<td style="text-align:right">$1</td>
</tr>
</tbody>
</table>
<p>这种语法生成的表格如下：<br><img src="http://ww2.sinaimg.cn/large/762694bagw1f46im2iiw4j20ey06qjs3.jpg" alt=""></p>
<h3 id="代码框"><a href="#代码框" class="headerlink" title="代码框"></a>代码框</h3><p>如果你是个程序猿，需要在文章里优雅的引用代码框，在 <strong>Markdown</strong> 下实现也非常简单，如 <code>code</code>,只需要用两个`把中间的代码包裹起来，图例：<br><img src="http://ww3.sinaimg.cn/large/6aee7dbbgw1effg1lsa97j20lt0a8dgs.jpg" alt=""></p>
<p>还有一种Fenced Code Block，写法是：第一行和最后一行都是3个 “ ` “，中间的行是代码，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;code&gt;</span><br></pre></td></tr></table></figure>
<p>还有块代码(block code)的写法：代码每一行的前面都加4个空格或一个tab</p>
<pre><code>are you ok?
</code></pre><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><p>分割线的语法只需要三个 <code>*</code> 号，例如：</p>
<hr>
<pre><code>到这里，Markdown 的基本语法在日常的使用中基本就没什么大问题了，只要多加练习，配合好用的工具，写起东西来肯定会行云流水。更多的语法规则，其实 Mou 的 Help 文档栗子很好，当你第一次使用 Mou 时，就会显示该文档。可以用来对用的查找和学习。
</code></pre><h3 id="相关推荐"><a href="#相关推荐" class="headerlink" title="相关推荐"></a>相关推荐</h3><h4 id="可配套使用的工具"><a href="#可配套使用的工具" class="headerlink" title="可配套使用的工具"></a>可配套使用的工具</h4><ul>
<li><a href="http://droplr.com" target="_blank" rel="external">Droplr</a></li>
<li><a href="https://www.getcloudapp.com" target="_blank" rel="external">Cloudapp</a></li>
<li><a href="ezShare for Mac">ezShare for Mac</a></li>
<li><a href="http://weibotuchuang.sinaapp.com" target="_blank" rel="external">围脖图床修复计划</a></li>
<li><a href="https://maxiang.io" target="_blank" rel="external">马克飞象</a></li>
</ul>
<h4 id="相关文章阅读"><a href="#相关文章阅读" class="headerlink" title="相关文章阅读"></a>相关文章阅读</h4><ul>
<li><a href="http://www.jianshu.com/p/qqgjln" target="_blank" rel="external">为什么作家应该用 Markdown 保存自己的文稿</a></li>
<li><a href="http://www.yangzhiping.com/tech/r-markdown-knitr.html" target="_blank" rel="external">Markdown写作浅谈</a></li>
<li><a href="http://www.appinn.com/markdown-tools/" target="_blank" rel="external">Markdown 工具补完</a></li>
<li><a href="http://www.jianshu.com/p/63HYZ6" target="_blank" rel="external">Drafts + Scriptogr.am + Dropbox 打造移动端 Markdown 风格博客</a></li>
<li><a href="http://www.ituring.com.cn/article/23" target="_blank" rel="external">怎样使用Markdown</a></li>
<li><a href="http://news.cnblogs.com/n/139649/" target="_blank" rel="external">为什么我们要学习 Markdown 的三个理由</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/07/06/git常用的基础命令/" itemprop="url">
                  Git常用的基础命令
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-07-06T21:14:21+08:00" content="2015-07-06">
              2015-07-06
            </time>
          </span>

          

          
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#Git常用的基础命令</p>
<h2 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h2><p><strong>用户信息</strong><br></p>
<p>配置你个人的用户名称和电子邮件地址。这两条配置很重要，每次 Git 提交时都会引用这两条信息，说明是谁提交了更新，所以会随更新内容一起被永久纳入历史记录：<br><br><code>git config --global user.name “youname”</code><br><code>git config --global user.email “12345@example.com”</code>    </p>
<p>如果用了 —global 选项，那么更改的配置文件就是位于你用户主目录下的那个，以后你所有的项目都会默认使用这里配置的用户信息。如果要在某个特定的项目中使用其他名字或者电邮，只要去掉 —global 选项重新配置即可，新的设定保存在当前项目的 .git/config 文件里。<br><br></p>
<p>##GIT基础<br><strong>查看配置信息</strong><br>查看已有的配置信息<br><code>git config --list</code><br><code>git config -l</code></p>
<p><strong>获取帮助</strong><br>例如想获取config命令的帮助信息<br><code>git help config</code><br><code>git config --help</code>    </p>
<p><strong>初始化新仓库</strong><br><code>git init</code></p>
<p>初始化后，在当前目录下会出现一个名为 .git 的目录，所有 Git 需要的数据和资源都存放在这个目录中。不过目前，仅仅是按照既有的结构框架初始化好了里边所有的文件和目录，但我们还没有开始跟踪管理项目中的任何一个文件。</p>
<p>如果当前目录下有几个文件想要纳入版本控制，需要先用 git add 命令告诉 Git 开始对这些文件进行跟踪，然后提交：<br><strong>跟踪文件：</strong>（将文件加到暂存区域）<br> <code>git add readme.txt</code>    </p>
<p> <strong>跟踪全部文件</strong><br><code>git add .</code></p>
<p><strong>提交更新</strong><br><code>git commit -m “first version”</code>    </p>
<p><strong>上传（推送）到github</strong><br><code>git push origin master</code></p>
<p><strong>从现有仓库克隆</strong><br><code>git clone git://github.com/youname/project.git</code><br><code>git clone git@github.com:youname/project.git</code><br><code>git clone https://github.com/youname/project.git</code>    </p>
<p><strong>检查当前文件状态</strong><br><code>git status</code>    </p>
<p><strong>创建.gitignore文件</strong><br><code>touch .gitignore</code>    </p>
<p><strong>查看修改之后没有暂存起来的内容</strong><br><code>git diff</code>    </p>
<p><strong>移除文件</strong><br><code>git rm readme.txt</code>    </p>
<p><strong>重命名文件</strong><br><code>git mv oldname.txt newname.txt</code></p>
<p><strong>查看提交历史</strong><br><code>git log</code>    </p>
<p><strong>取消暂存</strong><br><code>git reset HEAD readme.txt</code>     </p>
<p><strong>添加远程仓库</strong>（远程仓库必须先在github上建好）<br><code>git remote add [shortname] [url]</code></p>
<p><strong>实例：</strong><br><code>git remote add origin git@github.com:youname/yourRepo.git</code>    </p>
<p><strong>推送数据到仓库</strong><br><code>git push [remote-name] [branch-name]</code>    </p>
<p>如果要把本地的 master 分支推送到origin服务器上（再次说明下，克隆操作会自动使用默认的master 和origin 名字），可以运行下面的命令：<br><code>git push origin master</code>    </p>
<p><strong>从远程仓库抓取数据</strong><br><code>git fetch [remote-name]</code>  </p>
<p>碰到远端仓库服务器迁移，或者原来的克隆镜像不再使用，又或者某个参与者不再贡献代码，那么需要移除对应的远端仓库<br><strong>远程仓库的删除</strong><br><code>git remote rm origin</code>    </p>
<p><strong>远程仓库重命名</strong>(此处命名的是上文添加远程仓库中的shortname)<br><code>git remote rename origin origin2</code>    </p>
<p><strong>自动补全</strong><br>输入命令后按tab键，就会看到列出所有匹配的可用命令建议：<br><br><code>git co&lt;tab&gt;</code><br><br></p>
<p>#GIT分支<br><strong>创建一个名为“testing”的分支</strong><br><br><code>git branch testing</code><br></p>
<p><strong>切换到“testing”分支</strong>(默认为master分支)<br><br><code>git checkout testing</code><br></p>
<p><strong>新建并切换到该分支</strong><br><br><code>git checkout -b iss53</code><br></p>
<p><strong>这条命令相当于执行下面这两条命令</strong><br><br><code>git branch iss53</code><br><br><code>git checkout iss53</code><br></p>
<p><strong>删除hotfix分支</strong>（如果该分支还未被合并则会提示错误，因为这样会丢失数据）<br><br><code>git branch -d hotfix</code><br></p>
<p><strong>强制删除hotfix分支</strong>（强制删除，不会提示错误）<br><br><code>git branch -D hotfix</code><br></p>
<p><strong>合并iss53分支</strong>（先切换到master分支）<br><br><code>git checkout master</code><br><br><code>git merge iss53</code><br></p>
<p><strong>查看当前所有分支</strong><br><br><code>git branch</code><br></p>
<p><strong>查看各个分支最后一个提交对象的信息</strong><br><br><code>git branch -v</code><br></p>
<p><strong>查看已经与当前分支合并的分支</strong>（已经合并的查出来后可以删掉）<br><br><code>git branch --merge</code><br></p>
<p><strong>查看未与当前分支合并的分支</strong><br><br><code>git branch --no-merged</code><br></p>
<p><strong>同步远程服务器数据到本地</strong><br><br><code>git fetch origin</code><br></p>
<p><strong>从新添加的远程仓库下载数据</strong><br><br><code>git remote add teamone git://git.team1.ourcompany.com</code><br><br><code>git fetch teamone</code><br></p>
<p><strong>分化一个新的分支</strong>(使用这个命令会从服务器上下载master最新的版本，所以如果当前本地版本不是最新的，新的分支和本地分支会不同)<br><br><code>git checkout -b test1 origin/master</code><br></p>
<p>假如你用这个新的分支进行git push，并且通过了合并，那么会在远程仓库建立一个新的同名分支<br><br><strong>删除该分支的方法</strong><br><br><code>git push origin :test1</code><br></p>
<p><strong>分支的衍合：</strong>将test1分支衍合到master主分支<br><br><code>git checkout test1</code><br><br><code>git rebase master</code><br></p>
<p><strong>另一种方法，直接衍合，不用再先切换到test1</strong><br><br><code>git rebase master test1</code><br></p>
<p><strong>快进master分支</strong><br><br><code>git checkout master</code><br><br><code>git merge client</code><br></p>
<p>衍合：一旦分支中的提交对象发布到公共仓库，就千万不要对该分支进行衍合操作。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/07/01/CocoaPods安装和使用/" itemprop="url">
                  cocoaPods安装使用和常见问题
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-07-01T22:10:41+08:00" content="2015-07-01">
              2015-07-01
            </time>
          </span>

          

          
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="cocoaPods安装使用和常见问题"><a href="#cocoaPods安装使用和常见问题" class="headerlink" title="cocoaPods安装使用和常见问题"></a>cocoaPods安装使用和常见问题</h1><h2 id="一、什么是CocoaPods"><a href="#一、什么是CocoaPods" class="headerlink" title="一、什么是CocoaPods"></a>一、什么是CocoaPods</h2><p>CocoaPods是iOS项目的依赖管理工具，该项目源码在Github上管理。开发iOS项目不可避免地要使用第三方开源库，CocoaPods的出现使得我们可以节省设置和第三方开源库的时间。</p>
<p>在使用CocoaPods之前，开发项目需要用到第三方开源库的时候，我们需要：</p>
<ul>
<li>把开源库的源代码复制到项目中</li>
<li>添加一些依赖框架和动态库</li>
<li>设置-ObjC，-fno-objc-arc等参数</li>
<li>管理他们的更新</li>
</ul>
<p>在使用CocoaPods后，我们只需要把用到的开源库放到一个名为Podfile的文件中，然后执行pod install.Cocoapods就会自动将这些第三方开源库的源码下载下来，并且为我们的工程设置好响应的系统依赖和编译参数。</p>
<h2 id="二、CocoaPods的原理"><a href="#二、CocoaPods的原理" class="headerlink" title="二、CocoaPods的原理"></a>二、CocoaPods的原理</h2><p>CocoaPods的原理是将所有的依赖库都放到另一个名为Pods的项目中，然后让主项目依赖Pods项目，这样，源码管理工作都从主项目移到了Pods项目中。Pods项目最终会编译成一个名为libPods.a的文件，主项目只需要依赖这个.a文件即可。</p>
<h2 id="三、CocoaPods的安装"><a href="#三、CocoaPods的安装" class="headerlink" title="三、CocoaPods的安装"></a>三、CocoaPods的安装</h2><p>CocoaPods可以方便地通过Mac自带的RubyGems安装。<br>在安装CocoaPods之前，首先要在本地安装好Ruby环境。</p>
<ul>
<li><p>查看下当前ruby版本：<br>打开终端输入 ruby -v (由于我已经安装了最新的ruby环境，显示是最新)<br><code>ruby 2.0.0p648 (2015-12-16 revision 53162) [universal.x86_64-darwin15]</code></p>
</li>
<li><p>更新ruby环境（ruby的软件源rubygems.org因为使用亚马逊的云服务，被我天朝屏蔽了，需要更新一下ruby的源到淘宝镜像）<br><code>$ gem sources -l (查看当前ruby的源)
$ gem sources --remove https://rubygems.org/（移除原来的ruby源路径）
$ gem sources -a https://ruby.taobao.org/（更新ruby的源到淘宝镜像）
$ gem sources -l （查看更新是否成功）</code></p>
</li>
</ul>
<p>只有在终端中出现下面文字才表明你上面的命令是成功的：<br><code>*** CURRENT SOURCES ***
http://ruby.taobao.org/</code></p>
<ul>
<li><p>如果gem太老，可以尝试用如下命令升级gem<br><code>sudo gem udate --system</code><br>升级成功后会提示: RubyGems system software updated</p>
</li>
<li><p>执行安装下载命令<br><code>sudo gem install -n /usr/local/bin cocoapods</code></p>
</li>
</ul>
<p>这时候应该没什么问题了(如果报告Operation not permitted…之类的错误,请参考第五节:常见问题)</p>
<ul>
<li>接下来进行安装，执行<br><code>pod setup</code></li>
</ul>
<p>Terminal会停留在 Setting up CocoaPods master repo 这个状态一段时间,是因为要进行下载安装,而且目录比较大,需要耐心等待一下.如果想加快速度,可使用cocoapods的镜像索引.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.cocoapods/</span><br><span class="line">du -sh *</span><br></pre></td></tr></table></figure></p>
<p>安装成功后,你会看到终端打印出:<br><code>Setuo completed</code></p>
<p>查看cocoaPods版本，验证是否初始化成功<br><code>pod --version</code><br>我的打印结果：0.39.0</p>
<h2 id="四、CocoaPods的使用"><a href="#四、CocoaPods的使用" class="headerlink" title="四、CocoaPods的使用"></a>四、CocoaPods的使用</h2><h3 id="利用CocoaPods，在项目中导入AFNetworking类库"><a href="#利用CocoaPods，在项目中导入AFNetworking类库" class="headerlink" title="利用CocoaPods，在项目中导入AFNetworking类库"></a>利用CocoaPods，在项目中导入AFNetworking类库</h3><p>AFNetworking类库在GitHub地址是：<a href="https://github.com/AFNetworking/AFNetworking" target="_blank" rel="external">https://github.com/AFNetworking/AFNetworking</a></p>
<p>为了确定AFNetworking是否支持CocoaPods，可以用CocoaPods的搜索功能验证一下。在终端中输入：<br><code>pod search AFNetworking</code></p>
<p>我们会在终端中看到关于AFNetworking相关类库的一些信息。找到AFNetworking类库，如下：<br> <img src="http://7xqh31.com1.z0.glb.clouddn.com/cocoaPods_setup.png" alt="cocoaPods_setup"></p>
<p>这说明，AFNetworking是支持CocoaPods，所以我们可以利用CocoaPods将AFNetworking导入你的项目中。</p>
<ul>
<li>1、先利用Xcode创建一个名字CocoaPodsDemo的项目，通过终端进入这个工程所在的根目录（cd + 拖拽CocoaPodsDemo文件夹到终端，再回车）</li>
<li>2、执行命令<code>touch Podfile</code><br>新建一个名为Podfile的文件（不能写成别的名字，也可以自己在工程根目录里面直接新建）<br><code>ls -a</code><br>打印：<br><code>.            .DS_Store        CocoaPodsDemo.xcodeproj    
..            CocoaPodsDemo        Podfile</code><br>打开CocoaPodsDemo文件夹也可以看到多出来一个Podfile文件</li>
<li>3、执行命令 <code>open -e Podfile</code><br>第一次执行这个命令,会有一个空白文件打开，可以先放在一边，<br>Podfile文件的格式应该如下：<br><code>platform :ios, &#39;7.0&#39;</code><br><code>pod &#39;AMap2DMap&#39;, &#39;~&gt; 2.5.0&#39;</code><br><code>pod &#39;AFNetworking&#39;, &#39;~&gt; 2.5.3&#39;</code><br><code>pod &#39;SDWebImage&#39;, &#39;~&gt; 3.7.2&#39;</code>   </li>
</ul>
<p>需要注意的几点：<br>platform那一行，ios三个字母都要小写，而且与前面的冒号之间不能有间隔，后面的版本号也可以不写，但是有些开源库对版本是有要求的，比如要在6.0以上才能运行，遇到这样的开源库就需要写上版本号。<br>platform下面就是Cocoapods需要集成的开源库，根据你的需要确定集成那些库。</p>
<p>把pod ‘AFNetworking’， ‘~&gt;3.1.0’<br>那一行复制到我们的Podfile文件中，保存修改。<br>然后在Terminal中执行 ：<br>pod install</p>
<p>结果报错：<br>Invalid <code>Podfile</code> file: syntax error, unexpected tIDENTIFIER, expecting end-of-input<br>pod ‘AFNetworking’， ‘~&gt;3.1.0’<br>                     ^. Updating CocoaPods might fix the issue.</p>
<p>按照提示更新cocoaPods：<br><code>sudo gem update -n /usr/local/bin  cocoapods</code><br>更新完成后，查看cocoaPods最新版本：<br><code>pod --version</code><br>打印：<br><code>1.0.0</code></p>
<p>发现pod第三方库始终不成功，其实是最新版本cocoaPods中Podfile里面文件格式有更改:<br><code>platform :ios, &#39;7.0&#39;</code><br><code>use_frameworks!</code><br><code>target &#39;CocoaPodsDemo&#39; do</code><br><code>pod &#39;AFNetworking&#39;, &#39;~&gt; 3.1.0&#39;</code><br><code>end</code>    </p>
<p>当终端打印出下面信息就表示初始化第三方库成功了：<br><code>Pod installation complete! There is 1 dependency from the Podfile and 1 total
pod installed.</code></p>
<p>同时终端还会打印这样一句提示：<br><code>[!] Please close any current Xcode sessions and use &#39;CocoaPodsDemo.xcworkspace&#39; for this project from now on.</code><br>表示以后打开项目就用 CocoaPodsDemo.xcworkspace 打开，而不是之前的.xcodeproj文件。</p>
<p>点击 CocoaPodsDemo.xcworkspace 打开之后工程之后，项目Xcode目录结构如下图：<br><img src="http://7xqh31.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-05-22%20%E4%B8%8B%E5%8D%889.15.34.png" alt="屏幕快照 2016-05-22 下午9.15.34"></p>
<p>这样，AFNetworking就已经下载完成并且设置好了编译参数和依赖，在你的项目任意代码文件中输入：<br><code>#import &lt;AFNetworking.h&gt;</code><br>编译不报错就表示导入成功了。如下图：</p>
<p>以后使用的时候切记如下三点：</p>
<ul>
<li>1.从此以后需要使用Cocoapods生成的 .xcworkspace文件来打开工程，而不是使用以前的.xcodeproj文件</li>
<li>2.每次更改了Podfile文件，都需要重新执行一次pod update命令</li>
<li>3.如果你发现import的时候没有提示AFNetworking的文件，可以在target-Build Settings下修改“User Header Search Paths”项，新增${SRCROOT}并选择rcursive，如下图:<br><img src="http://7xqh31.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-05-22%20%E4%B8%8B%E5%8D%889.25.23.png" alt="屏幕快照 2016-05-22 下午9.25.23"><br>设置完成后就可以在文件中直接引用第三方库的文件并使用了。<br>(注意，此时再引用第三方库的头文件要使用<code>#import &quot;AFNetworking.h&quot;</code>)</li>
</ul>
<p>ps:当执行pod install之后，除了Podfile，还会生成一个名为Podfile.lock的文件，它会锁定当前各依赖库的版本，之后即使多次执行pod install也不会更改版本，只有执行pod update才会改变Podfile.lock.在多人协作的时候，这样可以防止第三方库升级时候造成大家各自的第三方库版本不一致。所以在提交版本的时候不能把它落下，也不要添加到.gitignore中.</p>
<p>#五、常见问题</p>
<ul>
<li><p>1、单引号格式错误<br><code>[!] Invalid Podfile file: undefined local variable or method ‘en_US&#39; for #&lt;Pod::Podfile:0x00000102a5d8b0&gt;. Updating CocoaPods might fix the issue.</code><br>解决办法：系统偏好设置-键盘-文本-将“使用智能引号和破折号”一项取消勾选-再将podfile里面的单（双）引号修改一下                     </p>
</li>
<li><p>2、字符集错误<br><code>ArgumentError - invalid byte sequence in US-ASCII</code><br>解决办法：使用locale命令查看当前的字符集，如果都是zh，需要执行以下命令：<br><code>export LC_ALL=en_US.UTF-8
export LANG=en_US.UTF-8</code><br>然后再使用locale命令查看，已经改过来了 </p>
</li>
<li><p>3、项目 Target 中做了一些设置，CocoaPods 也做了默认的设置,两者设置不一致。<br><img src="http://7xqh31.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-05-22%20%E4%B8%8B%E5%8D%889.46.50.png" alt="屏幕快照 2016-05-22 下午9.46.50"></p>
</li>
</ul>
<p>解决方法：我想要使用 CocoaPods 中的设置，分别在我的项目中定义PODS_ROOT 和 Other Linker Flags的地方（build settings），把他们的值用$(inherited)替换掉，进入终端，执行 pod update<br>警告没了，回到 Xcode，build通过。<br>网上还流行另外一种简单粗暴的方法:点击项目文件 project.xcodeproj，右键显示包内容，用文本编辑器打开project.pbxproj，删除OTHER_LDFLAGS的地方，保存(这种我没试过)</p>
<ul>
<li>4、执行pod install还是pod update都卡在了Analyzing dependencies不动<br>原因：当执行以上两个命令的时候会升级CocoaPods的spec仓库。<br>解决方法：加一个参数可以省略这一步，然后速度就会提升不少。加参数的命令如下:<br><code>pod install --verbose --no-repo-update</code><br><code>pod update --verbose --no-repo-update</code></li>
</ul>
<h1 id="六、在项目中移除CocoaPods"><a href="#六、在项目中移除CocoaPods" class="headerlink" title="六、在项目中移除CocoaPods"></a>六、在项目中移除CocoaPods</h1><p>如果你觉得CocoaPods让你的项目出现了问题，不好用甚至是恶心，想将其从项目中彻底移除，也有方法：</p>
<ul>
<li>1.删除工程文件夹下的<code>Podfile</code>、<code>Podfile.lock</code>和<code>Pods</code>文件夹。</li>
<li>2.删除<code>xcworkspace</code>文件。</li>
<li>3.打开<code>xcodeproj</code>文件，删除项目中的<code>libpods.a</code>和<code>Pods.xcconfig</code>引用</li>
<li>4.打开<code>Build Phases</code>选项，删除<code>Check Pods Manifest.lock</code>和<code>Copy Pods Resources：</code><br>完成，编译运行，无错通过。</li>
</ul>
<h1 id="七、CocoaPods降低版本"><a href="#七、CocoaPods降低版本" class="headerlink" title="七、CocoaPods降低版本"></a>七、CocoaPods降低版本</h1><ul>
<li><p>1、移除pod组件<br>首先查看Cocoapods组件安装路径：<br><code>which pod</code><br>再手动移除这个组件 :<br><code>sudo rm -rf &lt;path&gt;</code></p>
</li>
<li><p>2、移除 RubyGems 中的 Cocoapods程序包<br>查看gems中本地程序包：<br><code>gem list</code><br>发现Cocoapods的程序包：</p>
<figure class="highlight plain"><figcaption><span>(1.0.0, 0.39.0)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cocoapods-core (1.0.0, 0.39.0)</span><br><span class="line">cocoapods-deintegrate (1.0.0)</span><br><span class="line">cocoapods-downloader (1.0.0, 0.9.3)</span><br><span class="line">cocoapods-plugins (1.0.0, 0.4.2)</span><br><span class="line">cocoapods-search (1.0.0, 0.1.0)</span><br><span class="line">cocoapods-stats (1.0.0, 0.6.2)</span><br><span class="line">cocoapods-trunk (1.0.0, 0.6.4)</span><br><span class="line">cocoapods-try (1.0.0, 0.5.1)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>移除程序包:<br><code>sudo gem uninstall cocoapods -v 1.0.0</code><br>输出：<br><code>Successfully uninstalled cocoapods-1.0.0</code><br>继续输入移除指令：<br><code>sudo gem uninstall cocoapods-core -v 1.0.0</code><br>输出：<br><code>Successfully uninstalled cocoapods-core -v 1.0.0</code></p>
<ul>
<li>3、安装较低版本：<br><code>sudo gem install cocoapods -v 0.39.0</code><br>安装成功后,查看版本信息：<br><code>pod --version</code><br>输出<br><code>0.39.0</code></li>
</ul>
<p>更多关于cocoaPods的信息，请参考<a href="https://github.com/CocoaPods/CocoaPods/wiki" target="_blank" rel="external">cocoaPods官方文档</a></p>
<p>关于RVM参考博客：<br><a href="http://www.cnblogs.com/hongfei/p/3678123.html" target="_blank" rel="external">http://www.cnblogs.com/hongfei/p/3678123.html</a><br><a href="http://www.cnblogs.com/wangyuyu/archive/2013/07/30/3224852.html" target="_blank" rel="external">http://www.cnblogs.com/wangyuyu/archive/2013/07/30/3224852.html</a><br><a href="https://ruby-china.org/wiki/rvm-guide" target="_blank" rel="external">https://ruby-china.org/wiki/rvm-guide</a></p>
<p>这个网址可以查看到最新版本的gem<br><a href="https://rubygems.org/gems/rubygems-update" target="_blank" rel="external">https://rubygems.org/gems/rubygems-update</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/default_avatar.jpg"
               alt="JosephIvon" />
          <p class="site-author-name" itemprop="name">JosephIvon</p>
          <p class="site-description motion-element" itemprop="description">iOS developer</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">4</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        <div class="links-of-blogroll motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">JosephIvon</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  


  




<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=0.5.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=0.5.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=0.5.0"></script>



  



  



  
  
  

  

  

</body>
</html>
